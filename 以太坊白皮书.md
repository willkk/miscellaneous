# 下一代智能合约及去中心化应用平台
中本聪2009开发的比特币是第一种没有实物支撑或内在价值，没有中心发行者的数字资产。比特币中实现分布式共识的底层区块链技术很快吸引了大家更多的注意力。经常提到的区块链应用包括：使用链上数字资产表示自定义的货币及金融工具（colored coin），底层物理设备的所有权（smart property），不可替代资产如域名（Namecoin）以及更复杂的应用，包括实现任意规则的代码直接控制的数字资产（smart contract）或者基于区块链的去中心化自治组织（DAOs）。Ethereum打算提供的是一个内置成熟的图灵完备的编程语言的区块链，这种编程语言可以用于创建合约，用来编码任意的状态转换函数，允许用户创建以上提到的任何系统以及很多其他的暂时想不到的。(注：从这里看出，以太坊的作者希望整合当时各种分布式代币系统的特性，建立一个通用的、具有图灵完备的智能合约编程语言的分布式应用平台)


# 目录
- 比特币及现有概念介绍
  - 历史
  - 比特币中的状态转换系统
  - 挖矿
  - Merkle树
  - 其他区块链应用
  - 脚本
- 以太坊（Ethereum）
  - 哲学
  - 以太坊账户
  - 消息和交易
  - 消息
  - 以太坊状态转换函数
  - 代码执行
  - 区块链和挖矿
- 应用
  - 代币系统
  - 金融衍生品及稳值货币
  - 身份和信用体系
  - 去中心化文件存储
  - 去中心化自治组织
  - 更多的应用
- 其他及问题
  - 改进的GHOST实现
  - 费用
  - 计算和图灵完备
  - 货币和保险
  - 挖矿中心化
  - 伸缩性
- 结论
- 备注及进一步阅读

# 比特币及现有概念介绍
## 历史
去中心化数字货币以及其他应用像财产登记已经存在几十年了。1980和1990年代的匿名电子现金协议，主要依赖于类似乔母盲签（Chaumian blinding）等加密原语，提供了一种高度隐私的货币，但由于对中心化中介机构的依赖使得它没有受到普遍欢迎。1998年，戴伟的b-money成为第一个引入通过解决计算难题及去中心化共识来发币的主意的提议。但他的提议缺少去中心化共识如何实现的细节。2005年，Hal Finney引入了“可复用工作量证明”的概念，该系统借鉴了b-money以及Adam Back的计算困难的Hashcash难题，但依然依赖于可信计算作为后端支持。2009年，中本聪（Satoshi Nakamoto）第一次真正实现了去中心化货币，他结合了通过公钥加密来管理所有权的原语及跟踪币的流动的共识算法（称为“工作量证明proof of work”）。
工作量证明机制是该领域的一个突破，因为它同时解决了两个问题。第一，它提供了一个简单但又相对有效的共识算法，允许网络中的节点一起表决一组公认的比特币账本状态更新；第二，它提供了一个机制，允许自由进入共识过程，解决了谁可以影响共识的政治问题，同时阻止了女巫攻击。能阻止攻击的原因是它为每个参与的节点设置了一个门槛，比如要求注册成唯一的实体，加入经济因素的门槛--每个节点的投票权重正比于节点自身的计算力。之后，另一种称为proof of stake的方法被提出来，它计算每个节点的权重正比于该节点的持币量，而不是计算资源。
## 比特币中的状态转换系统
![](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/statetransition.png)
从技术角度来说，比特币这样的加密货币账本可以被看做一个状态转换系统。其中“状态”包含所有现存比特币的所有权状态，“状态转换函数”输入一个状态和交易并输出新的状态结果。例如，在标准的银行系统中，状态就是余额表，交易就是从A转移$X到B的请求，而状态转换函数从A账户减去$X并向B增加$X。如果A最初就没有$X那么多，状态转换函数就返回错误。形式上可以做如下定义：
```go
APPLY(S,TX) -> S' or ERROR
上面的银行系统中：
APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30, Bob: $70 }
或者
APPLY({ Alice: $50, Bob: $50 },"send $70 from Alice to Bob") = ERROR
```
比特币中的“状态”是所有已挖出但未消费的比特币的集合（技术上称为“未花费交易输出”，即UTXO），其中每一个UTXO都有一个面额和所有者。一个交易可以有多个输入和一个或多个输出，每个输入都引用了一个UTXO和私钥加密签名，而每个输出都包含一个UTXO并被加入到“状态”中。
状态转换函数APPLY(S,TX) -> S'可以大致被定义为：

1. 对于每一个输入Tx：  
    * 如果引用的UTXO不在S中，返回错误。  
    * 如果提供的签名与UTXO的所有者不匹配，返回错误。
2. 如果所有输入的UTXO的面额总额小于所有输出UTXO的面额总额，返回错误。  
3. 移除所有的输入UTXO，增加所有输出UTXO，返回S'。  

举例来说，Alice要向Bob转11.7比特币。首先，Alice先查找她拥有的总额不少于11.7比特币的可用的一组UTXO。实际情况，Alice可能并不能正好获得11.7比特币，比如，可能获取到最低可用的6+4+2=12比特币。她然后创建以这三个UTXO作为输入和两个输出的交易，第一个输出是Bob作为所有者的11.7比特币，第二个输出是剩下的0.3个比特币“零钱”，所有者是Alice。
## 挖矿
![](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/block.png)
如果有值得信任的中心化服务，这个系统会很容易实现，使用中心化服务器保存状态即可。但比特币是一个去中心化系统，为了确认每个交易的顺序，需要把状态系统跟共识系统联合在一起。比特币去中心化共识过程要求网络中的节点持续地生成交易包，称为“block”。这个网络期望是大概每10分钟生成一个块，其中包含了时间戳，nonce，上一个块的hash以及上一个块之后发生的所有交易列表。这样，长时间之后，就构成了一个“区块链”，并持续更新来表示最新的比特币账本状态。
检查一个block是否有效的算法如下：  
1. 检查上一个block存在并且有效。  
2. 检查block的时间戳，大于上一个block并且小于未来两小时。  
3. 检查block的工作量证明是有效的。  
4. 设S[0]为上一个块结束后的区块链状态。  
5. 假设TX是本块的n个交易的列表，对于其中任意的第i个从0到n-1的交易有S[i+1] = APPLY(S[i],TX[i])，如果任意APPLY出错，退出并返回false。  
6. 返回true，并记录S[n]为当前块的结束状态。  

本质上，块中的每个交易都要提供一个有效的状态转换，从交易执行前的标准的状态到新的状态。这个状态可以从创世块genesis状态顺序执行每个块中的每个交易计算得到。另外，矿机包含交易到块中的顺序的先后是影响的。如果交易B花费的UTXO是被A创建的，则交易A在B之前block才是有效的。  

上面列表中的验证条件中其他系统所没有的是“工作量证明”的要求。准确来说就是每个块的double-SHA256 hash（256位数字），必须小于一个动态调整的目标值，编写该文档时大约是2^187。这样做的目的是让块的创建变得计算困难，因此阻止恶意攻击来篡改这个链。因为SHA256是一个完全不可预测的伪随机函数，创建有效块的唯一方式是简单的尝试、失败，然后重复增加nonce并计算新的hash是否匹配。

以现在的目标值\~2^187，网络需要大概\~2^69次尝试才能生成一个有效的块。通常，这个目标值每经过2016个块都会重新调整，保证每个新的块在网络中的生成速度平均在10分钟左右。为了补偿挖矿节点付出的计算工作，每个块的挖出节点都有权包含一个交易来凭空给予自己12.5个比特币。如果任何交易中所有输入的面额高于输出，差值也会被给予挖矿节点作为“交易费”。另外，这也是BTC发币的唯一机制，创世块genesis根本不包含币。

为了更好理解挖矿的目的，我们检查一下有恶意攻击者时会发生什么。因为比特币底层的加密被认为是安全的，攻击者会将目标定为比特币系统中没有加密直接保护的部分：交易顺序。攻击者的策略很简单：  
1. 发送100 BTC给商户，交换一些商品（最好是能快速发货的数字产品）。  
2. 等待商品发货。  
3. 生成另外一个交易，再把这100 BTC发送给自己。  
4. 设法使网络相信他的发送给自己100 BTC的交易先于发送出去的交易。  

一旦第一步完成，几分钟后，一些挖矿节点就会包含交易到块中，比如block 270。一小时后，后续的5个块会被包含进链中，这些block都间接指向这个交易并对其“确认”。这时，商户会最终接受到这笔支付，然后发货。因为是数字产品，我们假设可以立即发货。现在攻击者创建另外一个交易，转发100 BTC给自己，如果简单发送这个交易到网络中，交易并不会被处理。矿机会尝试执行APPLY(S,TX)然后发行TX消费的UTXO并不在“状态”（账户余额）中。所以，攻击者就创建一个链的“分支”，从挖另一个版本的block 270开始，指向上一个block 269，同时用新的交易（给自己转100 BTC）替代旧的交易（给商户转出100 BTC）。由于块数据不同，需要重新计算“工作量证明”。另外，攻击者新版本的block 270的hash也不同于原始链，所以原始链中的block 271-275并不指向它，因此原始链和攻击者的新链是完全分开的。规则是：分支中最长的链被接受为事实，即认为是主链。所以，合法的挖矿者会在block 275上开始工作，而攻击者会独立工作在自己新的分支上。攻击者为了使自己的分支变得最长，他需要有比所有的剩余网络节点更多的计算能力才能“追上”，即“51%攻击”。
## Merkle树
![](https://raw.githubusercontent.com/ethereum/www/master-postsale/src/extras/gh_wiki/spv_bitcoin.png)
左侧：只需要展示Merkle树中一小部分节点就可以证明一个分支的有效性。（**快速验证特性**）  
右侧：任何尝试改变Merkle树任何部分最终都会导致链上更高层某个地方的不一致。（**难以篡改特性**）  
比特币一个重要的伸缩特性就是block被存储在一个多层数据结构（Merkle Tree）。一个块的hash其实只是该块的头部header hash，大约200字节的数据块，包含了时间戳timestamp，累加器nonce，上一个块hash和存储了所有交易的Merkle树的根hash。Merkle树是一种二叉树，其中大量节点是最底层的包含了交易数据的叶子节点，剩余的中间节点每个节点是两个子节点的hash，还有一个“最顶层的中间节点”，称为root根节点。使用Merkle树的目的是允许块中的数据可以零碎地被发送（复制）：一个节点可以从一个地方只下载block header信息，然后从另外一个地方下载与该块相关的部分信息，然后确认该部分数据是正确的。原因是，hahs向上扩散：如果恶意用户尝试替换假的交易到Merkle树的底部，这样会改变上层节点，然后依次的上层节点，最终改变root节点以至于block hash。这会使比特币把它当成一个不同的块（几乎可以肯定PoW是无效的）。

Merkle树协议可以说对长期可持续来说是必不可少的。比特币网络中的“全量节点”存储和处理完整的每个块，占用大概15G（2014年4月），每月大概增长1G。当前，对于某些桌面电脑来说是可行的，但手机不行，将来只有商业用户和爱好者能参与。一种称为“简化支付验证”（SPV）的协议允许另一类节点的存在，称为“轻量节点”，它们下载block header，基于header验证PoW，然后只下载与这些block的交易相关的“分支”。这样，“轻量节点”就能以较强的安全保证来确认任何交易的状态和当前余额，而这只需要下载整个区块链中非常小的一部分就可以了。
## 其他比特币应用



## 参考文献：
1.	白皮书 https://github.com/ethereum/wiki/wiki/White-Paper


