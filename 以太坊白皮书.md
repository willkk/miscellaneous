# 下一代智能合约及去中心化应用平台
中本聪2009开发的比特币是第一种没有实物支撑或内在价值，没有中心发行者的数字资产。比特币中实现分布式共识的底层区块链技术很快吸引了大家更多的注意力。经常提到的区块链应用包括：使用链上数字资产表示自定义的货币及金融工具（colored coin），底层物理设备的所有权（smart property），不可替代资产如域名（Namecoin）以及更复杂的应用，包括实现任意规则的代码直接控制的数字资产（smart contract）或者基于区块链的去中心化自治组织（DAOs）。Ethereum打算提供的是一个内置成熟的图灵完备的编程语言的区块链，这种编程语言可以用于创建合约，用来编码任意的状态转换函数，允许用户创建以上提到的任何系统以及很多其他的暂时想不到的。<font color=red>(注：从这里看出，以太坊的作者希望整合当时各种分布式代币系统的特性，建立一个通用的、具有图灵完备的智能合约编程语言的分布式应用平台)</font>


# 目录
- 比特币及现有概念介绍
  - 历史
  - 比特币中的状态转换系统
  - 挖矿
  - Merkle树
  - 其他区块链应用
  - 脚本编程
- 以太坊（Ethereum）
  - 思想
  - 以太坊账户
  - 消息和交易
  - 消息
  - 以太坊状态转换函数
  - 代码执行
  - 区块链和挖矿
- 应用
  - 代币系统
  - 金融衍生品及稳值货币
  - 身份和信用体系
  - 去中心化文件存储
  - 去中心化自治组织
  - 更多的应用
- 其他及问题
  - 改进的GHOST实现
  - 费用
  - 计算和图灵完备
  - 货币和保险
  - 挖矿中心化
  - 伸缩性
- 结论
- 备注及进一步阅读

# 比特币及现有概念介绍
## 历史
去中心化数字货币以及其他应用像财产登记已经存在几十年了。1980和1990年代的匿名电子现金协议，主要依赖于类似乔母盲签（Chaumian blinding）等加密原语，提供了一种高度隐私的货币，但由于对中心化中介机构的依赖使得它没有受到普遍欢迎。1998年，戴伟的b-money成为第一个引入通过解决计算难题及去中心化共识来发币的主意的提议。但他的提议缺少去中心化共识如何实现的细节。2005年，Hal Finney引入了“可复用工作量证明”的概念，该系统借鉴了b-money以及Adam Back的计算困难的Hashcash难题，但依然依赖于可信计算作为后端支持。2009年，中本聪（Satoshi Nakamoto）第一次真正实现了去中心化货币，他结合了通过公钥加密来管理所有权的原语及跟踪币的流动的共识算法（称为“工作量证明proof of work”）。
工作量证明机制是该领域的一个突破，因为它同时解决了两个问题。第一，它提供了一个简单但又相对有效的共识算法，允许网络中的节点一起表决一组公认的比特币账本状态更新；第二，它提供了一个机制，允许自由进入共识过程，解决了谁可以影响共识的政治问题，同时阻止了女巫攻击。能阻止攻击的原因是它为每个参与的节点设置了一个门槛，比如要求注册成唯一的实体，加入经济因素的门槛--每个节点的投票权重正比于节点自身的计算力。之后，另一种称为proof of stake的方法被提出来，它计算每个节点的权重正比于该节点的持币量，而不是计算资源。
## 比特币中的状态转换系统
![](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/statetransition.png)
从技术角度来说，比特币这样的加密货币账本可以被看做一个状态转换系统。其中“状态”包含所有现存比特币的所有权状态，“状态转换函数”输入一个状态和交易并输出新的状态结果。例如，在标准的银行系统中，状态就是余额表，交易就是从A转移$X到B的请求，而状态转换函数从A账户减去$X并向B增加$X。如果A最初就没有$X那么多，状态转换函数就返回错误。形式上可以做如下定义：
```go
APPLY(S,TX) -> S' or ERROR
上面的银行系统中：
APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30, Bob: $70 }
或者
APPLY({ Alice: $50, Bob: $50 },"send $70 from Alice to Bob") = ERROR
```
比特币中的“状态”是所有已挖出但未消费的比特币的集合（技术上称为“未花费交易输出”，即UTXO），其中每一个UTXO都有一个面额和所有者。一个交易可以有多个输入和一个或多个输出，每个输入都引用了一个UTXO和私钥加密签名，而每个输出都包含一个UTXO并被加入到“状态”中。
状态转换函数`APPLY(S,TX) -> S'`可以大致被定义为：

1. 对于每一个输入Tx：  
    * 如果引用的UTXO不在S中，返回错误。  
    * 如果提供的签名与UTXO的所有者不匹配，返回错误。
2. 如果所有输入的UTXO的面额总额小于所有输出UTXO的面额总额，返回错误。  
3. 移除所有的输入UTXO，增加所有输出UTXO，返回S'。  

举例来说，Alice要向Bob转11.7比特币。首先，Alice先查找她拥有的总额不少于11.7比特币的可用的一组UTXO。实际情况，Alice可能并不能正好获得11.7比特币，比如，可能获取到最低可用的6+4+2=12比特币。她然后创建以这三个UTXO作为输入和两个输出的交易，第一个输出是Bob作为所有者的11.7比特币，第二个输出是剩下的0.3个比特币“零钱”，所有者是Alice。

## 挖矿
![](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/block.png)
如果有值得信任的中心化服务，这个系统会很容易实现，使用中心化服务器保存状态即可。但比特币是一个去中心化系统，为了确认每个交易的顺序，需要把状态系统跟共识系统联合在一起。比特币去中心化共识过程要求网络中的节点持续地生成交易包，称为“block”。这个网络期望是大概每10分钟生成一个块，其中包含了时间戳，nonce，上一个块的hash以及上一个块之后发生的所有交易列表。这样，长时间之后，就构成了一个“区块链”，并持续更新来表示最新的比特币账本状态。
检查一个block是否有效的算法如下：  
1. 检查上一个block存在并且有效。  
2. 检查block的时间戳，大于上一个block并且小于未来两小时。  
3. 检查block的工作量证明是有效的。  
4. 设S[0]为上一个块结束后的区块链状态。  
5. 假设TX是本块的n个交易的列表，对于其中任意的第i个从0到n-1的交易有`S[i+1] = APPLY(S[i],TX[i])`，如果任意APPLY出错，退出并返回false。  
6. 返回true，并记录S[n]为当前块的结束状态。  

本质上，块中的每个交易都要提供一个有效的状态转换，从交易执行前的标准的状态到新的状态。这个状态可以从创世块genesis状态顺序执行每个块中的每个交易计算得到。另外，矿机包含交易到块中的顺序的先后是影响的。如果交易B花费的UTXO是被A创建的，则交易A在B之前block才是有效的。  

上面列表中的验证条件中其他系统所没有的是“工作量证明”的要求。准确来说就是每个块的double-SHA256 hash（256位数字），必须小于一个动态调整的目标值，编写该文档时大约是2^187。这样做的目的是让块的创建变得计算困难，因此阻止恶意攻击来篡改这个链。因为SHA256是一个完全不可预测的伪随机函数，创建有效块的唯一方式是简单的尝试、失败，然后重复增加nonce并计算新的hash是否匹配。

以现在的目标值\~2^187，网络需要大概\~2^69次尝试才能生成一个有效的块。通常，这个目标值每经过2016个块都会重新调整，保证每个新的块在网络中的生成速度平均在10分钟左右。为了补偿挖矿节点付出的计算工作，每个块的挖出节点都有权包含一个交易来凭空给予自己12.5个比特币。如果任何交易中所有输入的面额高于输出，差值也会被给予挖矿节点作为“交易费”。另外，这也是BTC发币的唯一机制，创世块genesis根本不包含币。

为了更好理解挖矿的目的，我们检查一下有恶意攻击者时会发生什么。因为比特币底层的加密被认为是安全的，攻击者会将目标定为比特币系统中没有加密直接保护的部分：交易顺序。攻击者的策略很简单：  
1. 发送100 BTC给商户，交换一些商品（最好是能快速发货的数字产品）。  
2. 等待商品发货。  
3. 生成另外一个交易，再把这100 BTC发送给自己。  
4. 设法使网络相信他的发送给自己100 BTC的交易先于发送出去的交易。  

一旦第一步完成，几分钟后，一些挖矿节点就会包含交易到块中，比如block 270。一小时后，后续的5个块会被包含进链中，这些block都间接指向这个交易并对其“确认”。这时，商户会最终接受到这笔支付，然后发货。因为是数字产品，我们假设可以立即发货。现在攻击者创建另外一个交易，转发100 BTC给自己，如果简单发送这个交易到网络中，交易并不会被处理。矿机会尝试执行APPLY(S,TX)然后发行TX消费的UTXO并不在“状态”（账户余额）中。所以，攻击者就创建一个链的“分支”，从挖另一个版本的block 270开始，指向上一个block 269，同时用新的交易（给自己转100 BTC）替代旧的交易（给商户转出100 BTC）。由于块数据不同，需要重新计算“工作量证明”。另外，攻击者新版本的block 270的hash也不同于原始链，所以原始链中的block 271-275并不指向它，因此原始链和攻击者的新链是完全分开的。规则是：分支中最长的链被接受为事实，即认为是主链。所以，合法的挖矿者会在block 275上开始工作，而攻击者会独立工作在自己新的分支上。攻击者为了使自己的分支变得最长，他需要有比所有的剩余网络节点更多的计算能力才能“追上”，即“51%攻击”。
## Merkle树
![](https://raw.githubusercontent.com/ethereum/www/master-postsale/src/extras/gh_wiki/spv_bitcoin.png)  
左侧：只需要展示Merkle树中一小部分节点就可以证明一个分支的有效性。（**快速验证特性**）  
右侧：任何尝试改变Merkle树任何部分最终都会导致链上更高层某个地方的不一致。（**难以篡改特性**）  

比特币一个重要的伸缩特性就是block被存储在一个多层数据结构（Merkle Tree）。一个块的hash其实只是该块的头部header hash，大约200字节的数据块，包含了时间戳timestamp，累加器nonce，上一个块hash和存储了所有交易的Merkle树的根hash。Merkle树是一种二叉树，其中大量节点是最底层的包含了交易数据的叶子节点，剩余的中间节点每个节点是两个子节点的hash，还有一个“最顶层的中间节点”，称为root根节点。使用Merkle树的目的是允许块中的数据可以零碎地被发送（复制）：一个节点可以从一个地方只下载block header信息，然后从另外一个地方下载与该块相关的部分信息，然后确认该部分数据是正确的。原因是，hahs向上扩散：如果恶意用户尝试替换假的交易到Merkle树的底部，这样会改变上层节点，然后依次的上层节点，最终改变root节点以至于block hash。这会使比特币把它当成一个不同的块（几乎可以肯定PoW是无效的）。

Merkle树协议应该说对长期可持续来说是必不可少的。比特币网络中的“全量节点”存储和处理完整的每个块，占用大概15G（2014年4月），每月大概增长1G。当前，对于某些桌面电脑来说是可行的，但手机不行，将来只有商业用户和爱好者能参与。一种称为“简化支付验证”（SPV）的协议允许另一类节点的存在，称为“轻量节点”，它们下载block header，基于header验证PoW，然后只下载与这些block的交易相关的“分支”。这样，“轻量节点”就能以较强的安全保证来确认任何交易的状态和当前余额，而这只需要下载整个区块链中非常小的一部分就可以了。
## 其他比特币应用
采用底层的区块链想法并应用到其他概念中同样有很长时间了。1998年，Nick Szabo提出了“用户授权的安全房产证明”的概念，里面描述了新的可复制数据库技术的进步可以存储土地所有权信息到基于区块链的系统。他创造了复杂的框架，包含如宅基地，非法占用和佐治亚土地税等概念。但是当时并没有有效的可复制数据库技术，直到2009年比特币的去中心化共识机制被引入，其他类似应用才快速出现。  

  * **Namecoin** 创建于2010年。Namecoin被描述为一个去中心的名称注册数据库。在去中心化协议中，如比特币，Tor和BitMessage，需要有种方式来标识账号。当前已有的系统中，都是伪随机hash，如1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy， 但大家希望有一个易记的如“george”名字。但这样的名字又容易重复及被伪造，那么唯一的方案就是申请在先的原则，先申请成功后申请失败。Namecoin是类似想法中，最早的也是最成功的名称注册系统。
  * **Colored coins** colored coins（“彩币”）的目的是作为一个协议允许人们创建自己的数字货币，或者在比特币链上的数字代币。在“彩币”中，每个人通过为比特币中特定的UTXO设置一个颜色来发行新的货币。“彩币”递归设置该交易消费的其他UTXO为与交易输入相同的颜色。这样可以让用户钱包只保存特定颜色的UTXO并像普通比特币一样发送它们或回溯区块链来确定他们收到任意UTXO的颜色。
  *  **Metacoins** metacoin的想法是在比特币之上，有一个协议使用比特币交易来存储metacoin交易，但有一个不同的状态转换函数APPLY'。由于metacoin不能阻止无效的交易进入比特币区块链，所以加入了一条规则：如果`APPLY'(S,TX)`返回错误，协议默认执行`APPLY'(S,TX) = S`。这样提供了一种简单的机制去创建任意的加密协议，或许还包括比特币自身都无法实现的新特性，同时又有非常低的开发成本，因为挖矿和网络协议已经由比特币处理。Metacoin已经被用来实现某些种类的金融合约，名称注册和去中心化的交易所。

因此，总得来说，有两种方式来实现共识协议：创建一个独立的网络；在比特币之上创建一个协议。前一种方法，虽然在Namecoin这样的例子中相当成功，但很难实现；每个单独的实现都需要启动一个独立的区块链，以及创建和测试所有必要的状态转换和网络节点。另外，我们预计这些使用去中心化共识技术的应用遵循幂律分布，即大部分应用太小而不能保证它们自己的链。而且我们注意到，存在很多种的去中心应用，特别是去中心自治组织DAOs。

另一方面，基于比特币的方法，缺点是它并没有继承比特币的简化支付验证特性。SPV适用于比特币是因为它可以用区块链深度作为一种验证代理。一旦一个交易的之前的交易已经足够深，则可以很安全地认为它们已经是状态中合法的一部分。基于比特币的Meta协议在自己的上下文中，并不能阻止区块链包含那些无效的交易。因此，一个完全安全的SPV meta协议需要向前扫描一直到比特币区块链的开始来确定某些交易是否有效。当前，所有基于比特币实现的“轻量”Meta协议都依赖于一个受信任的服务器来提供数据，一个可以说是最高次最优化的结果，考虑到加密货币一个主要的目的就是消除信任设施。

## 脚本编程
即使没有任何扩展，比特币也确实促进了一个弱版本的“智能合约”概念的出现。比特币中的UTXO不仅可以被公钥，也可以被更复杂的基于stack栈的编程语言脚本所有。在这个例子中，花费UTXO的交易必须提供满足脚本的数据。实际上，即使是基本的公钥所有权机制也是通过脚本实现的：脚本输入椭圆曲线签名，对交易和拥有该UTXO的地址进行验证，如果成功返回1，否则返回0。还有其他更复杂的各种用途的脚本。例如，你可以构建一个需要2/3的私钥签名才能进行验证的脚本（称为“多重签名”）。这种方式对合作账户，安全储蓄账户以及一些商户托管账户场景很有用。脚本也可以用于支付赏金给计算难题的解决方案。你甚至可以构建一个脚本，比如声明“如果你能提供SPV证据证明你发送了一个等额的Dogecoin给我，那么这个比特币UTXO就是你的。”，本质上就是允许了去中心化的跨币交换。

但比特币中的脚本化语言有几个重要的限制：  
  * **缺乏图灵完备性** 就是说，尽管比特币支持很大一部分的计算子集，但它并不支持所有的计算。主要缺少的是循环，这主要是为了避免验证交易时出现无线循环；理论上，对于脚本程序员来说这是可以克服的，因为任何循环都可以通过if语句简单的重复底层代码多次来模拟，但这导致脚本占用了大量空间。例如，实现另一种替代的椭圆曲线签名算法可能需要256轮重复的乘法运算，每一轮计算都要单独包含在代码里。
  * **值无感知** UTXO脚本无法对可取款账户提供细粒度的控制。例如，一个强有力的oracle合约例子是套期保值合约，A和B存入等值$1000的BTC，30天后脚本发送等值$1000的BTC给A，剩余的给B，这要求oracle直到1 BTC值多少美元。即使是在当时，在信任和基础设施方面，这也是对全中心化的解决方案的一个巨大的改进。但UTXO是一个整体的，唯一的方式就是比较低效地生成很多各种面额的UTXO，让输出选择哪个发送给A，哪个发送给B。
  * **缺少状态** UTXO要么被花费，要么没有被花费。多阶段的合约或脚本没有办法保存其他中间状态。这使得生成多阶段合约、去中心化交易报价和两阶段加密提交协议（对安全计算赏金是必须的）很困难。同时也意味着UTXO只能被用于创建简单的，一次性的合约，而不是复杂的“多状态”的合约。并使得meta协议难以实现。二值状态以及对值的无感知也决定了另外一个重要的应用，即取款限制，也是不可能的。
  * **区块链无感知** UTXO对区块链数据是无感知的，比如nonce，timestamp，上一个块的hash等。这严重地限制了在赌博以及其他几种场景中的应用，这使脚本语言丧失了随机性带来的潜在的价值。

因此，我们看到了三种基于加密货币来创建高级应用的方法：创建新的区块链；在比特币之上使用脚本；在比特币之上创建mata协议。创建新的区块链可以不受限制地自由地创建新的特性，但是成本却是开发时间、自力更生（原词“bootstrapping effort”）和安全性。使用脚本易于实现和标准化，但功能有限。而meta协议，尽管比较简单，但存在伸缩性不好的缺点。通过以太坊，我们希望创建另一个框架，来提供更大的开发简单性及更强的轻量客户端属性方面的增益，同时允许应用共享成本低廉的环境和区块链安全。

## 以太坊
以太坊的目的是建立一种建立去中心化应用的替代协议，它提供不同的折中组合，我们认为这对于大部分去中心化应用都会是非常有用的，并且特别关注了，快速开发时间、小而很少使用的应用的安全性以及不同应用彼此交互能力这些非常重要的功能的应用场景。以太坊实现这个目标的方法是创建一个，本质上来说，最根本的抽象基础层：一个内置图灵完备编程语言的区块链，它允许任何人写智能合约和可以创建任意所有权规则、交易格式和状态转换函数的去中心化应用。一个简单版本的Namecoin只需要两行代码，其他货币和信用体系（原词“reputation system”）等协议可以不超过20行代码。智能合约（一种加密“盒子”，包含了值并且只有满足特定条件才能解锁），也可以创建在该平台之上。这要比比特币的脚本强大的多，因为添加了图灵完备性，值感知，区块链感知和状态。

### 思想（原词“Philosophy”）
以太坊背后的设计目的是遵守下列规则：
1. **简单性** 以太坊协议应该尽可能简单，即使需要更多的数据存储或牺牲一些时间效率。一个正常的程序员应该能遵守和实现全部的规范。这样他才能充分领会加密货币带来的前所未有的（原词“unprecedented”）民主化潜力，进一步推动以太坊的愿景，即成为一个向所有人开放的协议。任何增加复杂性的优化只有在它提供了重大的益处时才能被包含进来。
2. **通用性** 以太坊设计思想的一个基础部分是，以太坊并没有特性。相反，以太坊提供一个内部图灵完备的脚本编程语言。程序员可以使用该语言创建任何可以数学上定义的智能合约或交易类型。想要发明自己的金融衍生品？通过以太坊，你可以。想创造自己的货币?通过以太坊合约，你也可以。想要创建全量的Daemon和Skynet（注：两个美国科幻电影中的分布式网络），你可能需要几千个联锁的合约。
3. **模块化** 以太坊协议的各部分应该设计得尽可能模块化和独立。随着开发进程，我们的目标是创建这样一个应用：如果一个人在一个地方做了很小的修改，应用栈可以继续工作而不需要额外的修改。Ethash、改版的Patricia树和RLP应该，实际也是，实现为相互独立的功能完全的库。如此一来，即使以太坊不需要某些功能，这些功能也可以用在其他协议中。以太坊开发应该最大化地完成，这样可以造福整个加密货币生态系统，而不是只是自己。
4. **敏捷性** 以太坊协议的细节并不是固定不变的。尽管我们对于上层结构的修改非常谨慎，如sharding路线图，抽象执行，数据可用性仅限于共识等。开发过程中后期的计算测试使我们发现，某些修改，如协议架构和以太坊虚拟机EVM，极大地提升了伸缩性和安全性。只要有这样的机会，我们就会采纳。
5. **无差别对待和无审查** 协议不应该主动限制或组织特定种类的用法。协议中所有监管机制都应该设计为直接管控损害，而不试图抵制特定的不期望的应用。程序员甚至可以在以太坊上运行无限循环脚本任意长时间，只要他们愿意支付每个计算步骤的交易费用。

### 以太坊账户
以太坊中，状态由称为“账户”的对象组成，每个账户有一个20字节的地址和账户间值和信息的直接进行转移的状态转换。一个以太坊账户包含四个字段：
  - **nonce** 一个计数器，保证每个交易只能被处理一次。
  - 账户的当前以太币余额**eth balance**。
  - 账户的合约代码**contract code**，如果有的话。
  - 账户的存储信息**storage**，默认空。

“Ether”是以太坊中主要的内部加密燃料，被用来支付交易费用。通常，有两种账户：**外部所有账户**，受私钥控制；**合约账户**，受合约代码控制。外部所有账户没有代码，你可以通过外部所有账户来创建并签名一个交易来发送消息；合约账户中，每次接收到一个消息，它的代码就被激活，允许依次读写内部存储，发送其他消息或创建合约。

注意，以太坊中的“合约”不应当被看做“应该被实现或可被编译的”；相反，它们更像存在于以太坊执行环境中的“自治代理”，即每次被消息或交易“戳”的时候总是执行特定的代码片，并且能直接控制以太币余额和保存持久变量的键/值存储。

### 消息和交易
术语“交易”在以太坊中用来指签名的数据包，其中存储了外部所有账户发出的消息。交易包括：
  - 消息的接收者
  - 标识发送者的签名
  - 发送者到接收者之间要转移的以太币的数量
  - 可选的数据字段
  - `STARTGAS`值，表示交易执行允许的最大的计算步骤数
  - `GASPRICE`值，表示发送者每个计算步骤的费用

前三个字段是任何加密货币都应该有的标准字段。数据字段默认没用，但虚拟机有一个操作码可以被合约用来访问数据字段。例如，如果合约被作为一个链上的域名注册服务，它可能希望把数据字段解析成两个字段：第一个字段是需要注册的域名，第二个字段是需要注册到的IP地址。合约会从消息的数据字段读取这些值并恰当地存储它们。

`STARTGAS`和`GASPRICE`对以太坊的反DOS攻击模型至关重要。为了阻止代码中偶然的，敌意的无限循环或其他的计算消耗，每个交易要求设置一个代码执行的计算步骤数量的限制。计算的基本单位是“gas”，通常，一个计算步骤消耗一个gas。但有些操作消耗更多的gas，因为它们的计算成本更高，或者是增加了状态所必须的数据量。交易中的数据每个字节费用是5 gas。费用系统的目的是促使攻击者支付与他们消耗的资源成正比的成本，这些资源包括计算，带宽和存储。因此，任何导致了网络消耗更多这些资源的交易都必须支付正比于这些消耗的费用。
### 消息
合约能够发送“消息”给其他合约。消息是不会被序列化的虚拟对象，只存在于以太坊的执行环境中。一个消息包含：
  - 消息发送者（隐含）
  - 消息接收者
  - 随消息一起转移的以太币数量
  - 可选的数据字段
  - `STARTGAS`值

本质上，一个消息就像一个交易。只是它由合约生成，并不是外部参与者。当当前正在执行代码的合约执行到`CALL`操作码的时候，会生成一个消息，并执行它。和交易一样，消息也会导致接收方账户执行它的代码。这样，合约就可以跟外部参与者一样，与其他合约具有完全一样的关系。

注意，交易或合约赋值的gas限额适用于本交易及所有子交易的gas花费。例如，如果外部参与者A发送了一个交易，gas是1000，B发送消息给C时消耗了600 gas，C的内部执行又消耗了300 gas，那么B在消耗完gas之前还可以花费100 gas。
### 以太坊状态转换函数
![](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/ethertransition.png)
以太坊状态转换函数`APPLY(S,TX) -> S'`可以定义如下：
1. 检查交易格式是否良好（即值的数量正确），签名是否有效，nonce是否与发送者账户的nonce匹配。如果不正确，返回错误。
2. 计算交易费用，`STARTGAS * GASPRICE`，从签名中确定发送地址。从发送者账户余额中减掉上面这费用，增加发送者的nonce。如果余额不足，返回错误。
3. 初始化`GAS = STARTGAS`，按每个字节减掉一定数量的gas来支付交易中的字节数据。
4. 转移交易值从发送者账户到接收者账户。如果接收者账户并不存在，创建它。如果接受账户是合约账户，执行合约代码要么直到完成要么直到gas消耗完。
5. 如果由于发送者没有足够的钱而导致交易转移失败，或者代码执行消耗完了gas，还原所有的状态改变，支付的费用除外，并把这些费用添加到矿机的账户上。
6. 否则，退还所有剩余的gas给发送者，发送消耗的gas费用给矿机。

例如，假设我们的合约代码如下：
```go
if !self.storage[calldataload(0)]:
    self.storage[calldataload(0)] = calldataload(32)
```
注意，现实中，合约代码是以低级EVM代码编写的。这个例子以Serpent编写，为了清晰起见。假设合约存储起始是空的。发送了一个10以太币、2000 gas、0.001 gasprice、64字节数据（0-31字节表示数字2，32-63表示字符串`CHARLIE`）的交易后，这里的状态转换函数过程如下：
1. 检查交易有效并且格式良好。
2. 检查交易发送者至少有2000 * 0.001 = 2以太币，如果有，则从发送者账户减去2以太币。
3. 初始化gas = 2000；假设交易是170字节，每个字节费是5，则减掉850，剩下1150 gas。
4. 从发送者账户再减去10以太币到合约账户。
5. 执行代码。这里很简单：它检查合约存储下标为`2`的位置是否被使用，这里未被使用，所以它设置下标为`2`的存储位置的值为`CHARLIE`。假设这消耗了187 gas，所以剩下1150 - 187  = 963。
6. 返还963 * 0.001 = 0.963以太币到发送者账户，返回生成的结果状态。

如果在交易接收端没有合约，则总的交易费用就只是`GASPRICE`乘以交易的字节长度。随交易一起发送的数据是没有关系的。

注意，在状态还原方面，消息跟交易工作机制是一样的。如果一个消息执行消耗完了gas，那么该消息的执行以及所有该交易出发的其他执行全部还原，但更高一层的执行不必还原。这意味着一个合约调用另外一个是“安全”的，就好像A用G gas调用B，然后A的执行被保证最多消耗G gas。最后，有一个操作码`CREATE`，它可以创建一个合约，它的执行方式基本类似于`CALL`，只是执行的输出决定了新创建的合约的代码。

### 代码执行
以太坊合约中的代码是用低级的，基于栈的字节码语言编写的，称为“以太坊虚拟机代码”或“EVM code”。这个代码包含一系列字节，而每个字节表示一个操作。一般地，代码执行是一个无限循环，重复执行当前程序计数器指向的指令，然后将程序计数器加1直到代码结束或者错误，或者检测到`STOP`和`RETURN`指令。操作可以访问三种类型的存储空间：
  * **stack**，后进先出容器，可以允许值被压入或弹出。
  * **Memory**，可无限扩展的字节数组。
  * 合约的长期存储**storage**，key/value存储。不像stack或memory，计算结束后被重置，storage可以长期存留。

代码也可以访问进来的消息的值，发送者和数据，以及块头信息，也可以返回数据的字节数组作为输出。

EVM代码的正规执行模型是极其简单的。以太坊虚拟机运行时，它整个计算状态可以被定义为元组`(block_state, transaction, message, code, memory, stack, pc, gas)`，其中`block_state`是包含全部账户、余额和存储的全局状态。在每轮执行的开始，当前指令的计算是通过设置`pc`为`code`的值（0，如果`pc >= len(code)`），每个指令都有自己的定义如何来操作这个元组。例如，`ADD`从栈上弹出两个数据项，然后压入它们的和，减掉1 gas，然后将`pc`增加1；`SSTORE`从栈上弹出两个数据项，把第二个数据插入合约的storage中第一个数据项指定的下标中。尽管通过即时编译（原词“just-in-time compilation” ），有很多方式可以去优化以太坊虚拟机执行，但基本的以太坊实现只需要几百行代码就可以完成了。

### 区块链和挖矿
![](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/apply_block_diagram.png)
以太坊区块链很多方面都相似于比特币，但也有不同。不要的不同是，架构方面说来，不像比特币，以太坊block包含了交易列表和最新状态的拷贝。此外还有另外两个值，block块号和difficulty。以太坊中基本的块验证算法如下：
1. 检查引用的上一个块存在且有效。
2. 检查块的时间戳大于引用的上一个块，并且小于当前时间往后15分钟。
3. 检查块号，difficulty，交易root，uncle root（区块链中的未被采用的无效分支），gas limit有效。
4. 检查PoW有效。
5. 设`S[0]`为上一个块结束后的状态。
6. 设`TX`为块的交易列表，具有`n`个交易。对于所有的`i`，从`0...n-1`，设置`S[i+1] = APPLY(S[i],TX[i]`。如果任意应用失败，或如果总的gas消耗截止现在超过了`GASLIMIT`，返回错误。
7. 设`S_FINAL`为`S[n]`，添加块奖励给矿机miner。
8. 检查`S_FINAL`的状态树Merkle root是否等于块头中的状态root，如果是块有效，否则无效。

这个方法乍看起来很低效，每个块都要存储整个状态，但实际中效率是比得上比特币的。原因是状态存储在树结构中，生成每个块后只有很小的一部分树需要改变。因此，一般来说，相邻两个块，绝大部分都应该是相同的，因此数据可以被存储一次但被引用两次（通过hash）。一种特殊的树“Patricia树”被用来实现上述操作，它对Merkle树概念进行了修改，允许节点被高效地插入和删除，不仅仅是改变。另外，因为所有的状态信息都是最后一个block的一部分，也就没必要存储整个链的历史。这个策略如果应用到比特币，可以提供5-20倍的空间利用率。

经常问的问题是，从物理硬件角度来说，合约代码在哪执行。答案很简单：执行合约代码的过程是状态转换函数定义的一部分，它又是块验证算法的一部分。所以如果一个交易被加入到块`B`中，那么这个交易生成的代码执行（原词"code execution"）会被所有下载和验证block `B`的节点执行。

## 应用

## 参考文献：
1.	白皮书 https://github.com/ethereum/wiki/wiki/White-Paper







