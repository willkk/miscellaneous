# 下一代智能合约及去中心化应用平台
中本聪2009开发的比特币是第一种没有实物支撑或内在价值，没有中心发行者的数字资产。比特币中实现分布式共识的底层区块链技术很快吸引了大家更多的注意力。经常提到的区块链应用包括：使用链上数字资产表示自定义的货币及金融工具（colored coin），底层物理设备的所有权（smart property），不可替代资产如域名（Namecoin）以及更复杂的应用，包括实现任意规则的代码直接控制的数字资产（smart contract）或者基于区块链的去中心化自治组织（DAOs）。Ethereum打算提供的是一个内置成熟的图灵完备的编程语言的区块链，这种编程语言可以用于创建合约，用来编码任意的状态转换函数，允许用户创建以上提到的任何系统以及很多其他的暂时想不到的。<font color=red>(注：从这里看出，以太坊的作者希望整合当时各种分布式代币系统的特性，建立一个通用的、具有图灵完备的智能合约编程语言的分布式应用平台)</font>


# 目录
- [比特币及现有概念介绍](#1)
  - [历史](#1.1)
  - [比特币中的状态转换系统](#1.2)
  - [挖矿](#1.3)
  - [Merkle树](#1.4)
  - [其他区块链应用](#1.5)
  - [脚本编程](#1.6)
- [以太坊（Ethereum）](#2)
  - [思想](#2.1)
  - [以太坊账户](#2.2)
  - [消息和交易](#2.3)
  - [消息](#2.4)
  - [以太坊状态转换函数](#2.5)
  - [代码执行](#2.6)
  - [区块链和挖矿](#2.7)
- [应用](#3)
  - [代币系统](#3.1)
  - [金融衍生品及稳值货币](#3.2)
  - [身份和信用体系](#3.3)
  - [去中心化文件存储](#3.4)
  - [去中心化自治组织](#3.5)
  - [更多的应用](#3.6)
- [其他及问题](#4)
  - [改进的GHOST实现](#4.1)
  - [费用](#4.2)
  - [计算和图灵完备](#4.3)
  - [货币和发行](#4.4)
  - [挖矿中心化](#4.5)
  - [伸缩性](#4.6)
- [结论](#5)
- [备注及进一步阅读](#6)
  - [备注](#6.1)
  - [进一步阅读](#6.2)

# <a id="1">比特币及现有概念介绍</a>
## <a id="1.1">历史</a>
去中心化数字货币以及其他应用像财产登记已经存在几十年了。1980和1990年代的匿名电子现金协议，主要依赖于类似乔母盲签（Chaumian blinding）等加密原语，提供了一种高度隐私的货币，但由于对中心化中介机构的依赖使得它没有受到普遍欢迎。1998年，戴伟的b-money成为第一个引入通过解决计算难题及去中心化共识来发币的主意的提议。但他的提议缺少去中心化共识如何实现的细节。2005年，Hal Finney引入了“可复用工作量证明”的概念，该系统借鉴了b-money以及Adam Back的计算困难的Hashcash难题，但依然依赖于可信计算作为后端支持。2009年，中本聪（Satoshi Nakamoto）第一次真正实现了去中心化货币，他结合了通过公钥加密来管理所有权的原语及跟踪币的流动的共识算法（称为“工作量证明proof of work”）。
工作量证明机制是该领域的一个突破，因为它同时解决了两个问题。第一，它提供了一个简单但又相对有效的共识算法，允许网络中的节点一起表决一组公认的比特币账本状态更新；第二，它提供了一个机制，允许自由进入共识过程，解决了谁可以影响共识的政治问题，同时阻止了女巫攻击。能阻止攻击的原因是它为每个参与的节点设置了一个门槛，比如要求注册成唯一的实体，加入经济因素的门槛--每个节点的投票权重正比于节点自身的计算力。之后，另一种称为proof of stake的方法被提出来，它计算每个节点的权重正比于该节点的持币量，而不是计算资源。
## <a id="1.2">比特币中的状态转换系统</a>
![](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/statetransition.png)
从技术角度来说，比特币这样的加密货币账本可以被看做一个状态转换系统。其中“状态”包含所有现存比特币的所有权状态，“状态转换函数”输入一个状态和交易并输出新的状态结果。例如，在标准的银行系统中，状态就是余额表，交易就是从A转移$X到B的请求，而状态转换函数从A账户减去$X并向B增加$X。如果A最初就没有$X那么多，状态转换函数就返回错误。形式上可以做如下定义：
```go
APPLY(S,TX) -> S' or ERROR
上面的银行系统中：
APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30, Bob: $70 }
或者
APPLY({ Alice: $50, Bob: $50 },"send $70 from Alice to Bob") = ERROR
```
比特币中的“状态”是所有已挖出但未消费的比特币的集合（技术上称为“未花费交易输出”，即UTXO），其中每一个UTXO都有一个面额和所有者。一个交易可以有多个输入和一个或多个输出，每个输入都引用了一个UTXO和私钥加密签名，而每个输出都包含一个UTXO并被加入到“状态”中。
状态转换函数`APPLY(S,TX) -> S'`可以大致被定义为：

1. 对于每一个输入Tx：  
    * 如果引用的UTXO不在S中，返回错误。  
    * 如果提供的签名与UTXO的所有者不匹配，返回错误。
2. 如果所有输入的UTXO的面额总额小于所有输出UTXO的面额总额，返回错误。  
3. 移除所有的输入UTXO，增加所有输出UTXO，返回S'。  

举例来说，Alice要向Bob转11.7比特币。首先，Alice先查找她拥有的总额不少于11.7比特币的可用的一组UTXO。实际情况，Alice可能并不能正好获得11.7比特币，比如，可能获取到最低可用的6+4+2=12比特币。她然后创建以这三个UTXO作为输入和两个输出的交易，第一个输出是Bob作为所有者的11.7比特币，第二个输出是剩下的0.3个比特币“零钱”，所有者是Alice。

## <a id="1.3">挖矿</a>
![](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/block.png)
如果有值得信任的中心化服务，这个系统会很容易实现，使用中心化服务器保存状态即可。但比特币是一个去中心化系统，为了确认每个交易的顺序，需要把状态系统跟共识系统联合在一起。比特币去中心化共识过程要求网络中的节点持续地生成交易包，称为“block”。这个网络期望是大概每10分钟生成一个块，其中包含了时间戳，nonce，上一个块的hash以及上一个块之后发生的所有交易列表。这样，长时间之后，就构成了一个“区块链”，并持续更新来表示最新的比特币账本状态。
检查一个block是否有效的算法如下：  
1. 检查上一个block存在并且有效。  
2. 检查block的时间戳，大于上一个block并且小于未来两小时。  
3. 检查block的工作量证明是有效的。  
4. 设S[0]为上一个块结束后的区块链状态。  
5. 假设TX是本块的n个交易的列表，对于其中任意的第i个从0到n-1的交易有`S[i+1] = APPLY(S[i],TX[i])`，如果任意APPLY出错，退出并返回false。  
6. 返回true，并记录S[n]为当前块的结束状态。  

本质上，块中的每个交易都要提供一个有效的状态转换，从交易执行前的标准的状态到新的状态。这个状态可以从创世块genesis状态顺序执行每个块中的每个交易计算得到。另外，矿机包含交易到块中的顺序的先后是影响的。如果交易B花费的UTXO是被A创建的，则交易A在B之前block才是有效的。  

上面列表中的验证条件中其他系统所没有的是“工作量证明”的要求。准确来说就是每个块的double-SHA256 hash（256位数字），必须小于一个动态调整的目标值，编写该文档时大约是2<sup>187</sup>。这样做的目的是让块的创建变得计算困难，因此阻止恶意攻击来篡改这个链。因为SHA256是一个完全不可预测的伪随机函数，创建有效块的唯一方式是简单的尝试、失败，然后重复增加nonce并计算新的hash是否匹配。

以现在的目标值\~2<sup>187</sup>，网络需要大概\~2<sup>69</sup>次尝试才能生成一个有效的块。通常，这个目标值每经过2016个块都会重新调整，保证每个新的块在网络中的生成速度平均在10分钟左右。为了补偿挖矿节点付出的计算工作，每个块的挖出节点都有权包含一个交易来凭空给予自己12.5个比特币。如果任何交易中所有输入的面额高于输出，差值也会被给予挖矿节点作为“交易费”。另外，这也是BTC发币的唯一机制，创世块genesis根本不包含币。

为了更好理解挖矿的目的，我们检查一下有恶意攻击者时会发生什么。因为比特币底层的加密被认为是安全的，攻击者会将目标定为比特币系统中没有加密直接保护的部分：交易顺序。攻击者的策略很简单：  
1. 发送100 BTC给商户，交换一些商品（最好是能快速发货的数字产品）。  
2. 等待商品发货。  
3. 生成另外一个交易，再把这100 BTC发送给自己。  
4. 设法使网络相信他的发送给自己100 BTC的交易先于发送出去的交易。  

一旦第一步完成，几分钟后，一些挖矿节点就会包含交易到块中，比如block 270。一小时后，后续的5个块会被包含进链中，这些block都间接指向这个交易并对其“确认”。这时，商户会最终接受到这笔支付，然后发货。因为是数字产品，我们假设可以立即发货。现在攻击者创建另外一个交易，转发100 BTC给自己，如果简单发送这个交易到网络中，交易并不会被处理。矿机会尝试执行APPLY(S,TX)然后发行TX消费的UTXO并不在“状态”（账户余额）中。所以，攻击者就创建一个链的“分支”，从挖另一个版本的block 270开始，指向上一个block 269，同时用新的交易（给自己转100 BTC）替代旧的交易（给商户转出100 BTC）。由于块数据不同，需要重新计算“工作量证明”。另外，攻击者新版本的block 270的hash也不同于原始链，所以原始链中的block 271-275并不指向它，因此原始链和攻击者的新链是完全分开的。规则是：分支中最长的链被接受为事实，即认为是主链。所以，合法的挖矿者会在block 275上开始工作，而攻击者会独立工作在自己新的分支上。攻击者为了使自己的分支变得最长，他需要有比所有的剩余网络节点更多的计算能力才能“追上”，即“51%攻击”。
## <a id="1.4">Merkle树</a>
![](https://raw.githubusercontent.com/ethereum/www/master-postsale/src/extras/gh_wiki/spv_bitcoin.png)  
左侧：只需要展示Merkle树中一小部分节点就可以证明一个分支的有效性。（**快速验证特性**）  
右侧：任何尝试改变Merkle树任何部分最终都会导致链上更高层某个地方的不一致。（**难以篡改特性**）  

比特币一个重要的伸缩特性就是block被存储在一个多层数据结构（Merkle Tree）。一个块的hash其实只是该块的头部header hash，大约200字节的数据块，包含了时间戳timestamp，累加器nonce，上一个块hash和存储了所有交易的Merkle树的根hash。Merkle树是一种二叉树，其中大量节点是最底层的包含了交易数据的叶子节点，剩余的中间节点每个节点是两个子节点的hash，还有一个“最顶层的中间节点”，称为root根节点。使用Merkle树的目的是允许块中的数据可以零碎地被发送（复制）：一个节点可以从一个地方只下载block header信息，然后从另外一个地方下载与该块相关的部分信息，然后确认该部分数据是正确的。原因是，hahs向上扩散：如果恶意用户尝试替换假的交易到Merkle树的底部，这样会改变上层节点，然后依次的上层节点，最终改变root节点以至于block hash。这会使比特币把它当成一个不同的块（几乎可以肯定PoW是无效的）。

Merkle树协议应该说对长期可持续来说是必不可少的。比特币网络中的“全量节点”存储和处理完整的每个块，占用大概15G（2014年4月），每月大概增长1G。当前，对于某些桌面电脑来说是可行的，但手机不行，将来只有商业用户和爱好者能参与。一种称为“简化支付验证”（SPV）的协议允许另一类节点的存在，称为“轻量节点”，它们下载block header，基于header验证PoW，然后只下载与这些block的交易相关的“分支”。这样，“轻量节点”就能以较强的安全保证来确认任何交易的状态和当前余额，而这只需要下载整个区块链中非常小的一部分就可以了。
## <a id="1.5">其他比特币应用</a>
采用底层的区块链想法并应用到其他概念中同样有很长时间了。1998年，Nick Szabo提出了“用户授权的安全房产证明”的概念，里面描述了新的可复制数据库技术的进步可以存储土地所有权信息到基于区块链的系统。他创造了复杂的框架，包含如宅基地，非法占用和佐治亚土地税等概念。但是当时并没有有效的可复制数据库技术，直到2009年比特币的去中心化共识机制被引入，其他类似应用才快速出现。  

  * **Namecoin** 创建于2010年。Namecoin被描述为一个去中心的名称注册数据库。在去中心化协议中，如比特币，Tor和BitMessage，需要有种方式来标识账号。当前已有的系统中，都是伪随机hash，如1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy， 但大家希望有一个易记的如“george”名字。但这样的名字又容易重复及被伪造，那么唯一的方案就是申请在先的原则，先申请成功后申请失败。Namecoin是类似想法中，最早的也是最成功的名称注册系统。
  * **Colored coins** colored coins（“彩币”）的目的是作为一个协议允许人们创建自己的数字货币，或者在比特币链上的数字代币。在“彩币”中，每个人通过为比特币中特定的UTXO设置一个颜色来发行新的货币。“彩币”递归设置该交易消费的其他UTXO为与交易输入相同的颜色。这样可以让用户钱包只保存特定颜色的UTXO并像普通比特币一样发送它们或回溯区块链来确定他们收到任意UTXO的颜色。
  *  **Metacoins** metacoin的想法是在比特币之上，有一个协议使用比特币交易来存储metacoin交易，但有一个不同的状态转换函数APPLY'。由于metacoin不能阻止无效的交易进入比特币区块链，所以加入了一条规则：如果`APPLY'(S,TX)`返回错误，协议默认执行`APPLY'(S,TX) = S`。这样提供了一种简单的机制去创建任意的加密协议，或许还包括比特币自身都无法实现的新特性，同时又有非常低的开发成本，因为挖矿和网络协议已经由比特币处理。Metacoin已经被用来实现某些种类的金融合约，名称注册和去中心化的交易所。

因此，总得来说，有两种方式来实现共识协议：创建一个独立的网络；在比特币之上创建一个协议。前一种方法，虽然在Namecoin这样的例子中相当成功，但很难实现；每个单独的实现都需要启动一个独立的区块链，以及创建和测试所有必要的状态转换和网络节点。另外，我们预计这些使用去中心化共识技术的应用遵循幂律分布，即大部分应用太小而不能保证它们自己的链。而且我们注意到，存在很多种的去中心应用，特别是去中心自治组织DAOs。

另一方面，基于比特币的方法，缺点是它并没有继承比特币的简化支付验证特性。SPV适用于比特币是因为它可以用区块链深度作为一种验证代理。一旦一个交易的之前的交易已经足够深，则可以很安全地认为它们已经是状态中合法的一部分。基于比特币的Meta协议在自己的上下文中，并不能阻止区块链包含那些无效的交易。因此，一个完全安全的SPV meta协议需要向前扫描一直到比特币区块链的开始来确定某些交易是否有效。当前，所有基于比特币实现的“轻量”Meta协议都依赖于一个受信任的服务器来提供数据，一个可以说是最高次最优化的结果，考虑到加密货币一个主要的目的就是消除信任设施。

## <a id="1.6">脚本编程</a>
即使没有任何扩展，比特币也确实促进了一个弱版本的“智能合约”概念的出现。比特币中的UTXO不仅可以被公钥，也可以被更复杂的基于stack栈的编程语言脚本所有。在这个例子中，花费UTXO的交易必须提供满足脚本的数据。实际上，即使是基本的公钥所有权机制也是通过脚本实现的：脚本输入椭圆曲线签名，对交易和拥有该UTXO的地址进行验证，如果成功返回1，否则返回0。还有其他更复杂的各种用途的脚本。例如，你可以构建一个需要2/3的私钥签名才能进行验证的脚本（称为“多重签名”）。这种方式对合作账户，安全储蓄账户以及一些商户托管账户场景很有用。脚本也可以用于支付赏金给计算难题的解决方案。你甚至可以构建一个脚本，比如声明“如果你能提供SPV证据证明你发送了一个等额的Dogecoin给我，那么这个比特币UTXO就是你的。”，本质上就是允许了去中心化的跨币交换。

但比特币中的脚本化语言有几个重要的限制：  
  * **缺乏图灵完备性** 就是说，尽管比特币支持很大一部分的计算子集，但它并不支持所有的计算。主要缺少的是循环，这主要是为了避免验证交易时出现无线循环；理论上，对于脚本程序员来说这是可以克服的，因为任何循环都可以通过if语句简单的重复底层代码多次来模拟，但这导致脚本占用了大量空间。例如，实现另一种替代的椭圆曲线签名算法可能需要256轮重复的乘法运算，每一轮计算都要单独包含在代码里。
  * **值无感知** UTXO脚本无法对可取款账户提供细粒度的控制。例如，一个强有力的oracle合约例子是套期保值合约，A和B存入等值$1000的BTC，30天后脚本发送等值$1000的BTC给A，剩余的给B，这要求oracle直到1 BTC值多少美元。即使是在当时，在信任和基础设施方面，这也是对全中心化的解决方案的一个巨大的改进。但UTXO是一个整体的，唯一的方式就是比较低效地生成很多各种面额的UTXO，让输出选择哪个发送给A，哪个发送给B。
  * **缺少状态** UTXO要么被花费，要么没有被花费。多阶段的合约或脚本没有办法保存其他中间状态。这使得生成多阶段合约、去中心化交易报价和两阶段加密提交协议（对安全计算赏金是必须的）很困难。同时也意味着UTXO只能被用于创建简单的，一次性的合约，而不是复杂的“多状态”的合约。并使得meta协议难以实现。二值状态以及对值的无感知也决定了另外一个重要的应用，即取款限制，也是不可能的。
  * **区块链无感知** UTXO对区块链数据是无感知的，比如nonce，timestamp，上一个块的hash等。这严重地限制了在赌博以及其他几种场景中的应用，这使脚本语言丧失了随机性带来的潜在的价值。

因此，我们看到了三种基于加密货币来创建高级应用的方法：创建新的区块链；在比特币之上使用脚本；在比特币之上创建mata协议。创建新的区块链可以不受限制地自由地创建新的特性，但是成本却是开发时间、自力更生（原词“bootstrapping effort”）和安全性。使用脚本易于实现和标准化，但功能有限。而meta协议，尽管比较简单，但存在伸缩性不好的缺点。通过以太坊，我们希望创建另一个框架，来提供更大的开发简单性及更强的轻量客户端属性方面的增益，同时允许应用共享成本低廉的环境和区块链安全。

# <a id="2">以太坊</a>
以太坊的目的是建立一种建立去中心化应用的替代协议，它提供不同的折中组合，我们认为这对于大部分去中心化应用都会是非常有用的，并且特别关注了，快速开发时间、小而很少使用的应用的安全性以及不同应用彼此交互能力这些非常重要的功能的应用场景。以太坊实现这个目标的方法是创建一个，本质上来说，最根本的抽象基础层：一个内置图灵完备编程语言的区块链，它允许任何人写智能合约和可以创建任意所有权规则、交易格式和状态转换函数的去中心化应用。一个简单版本的Namecoin只需要两行代码，其他货币和信用体系（原词“reputation system”）等协议可以不超过20行代码。智能合约（一种加密“盒子”，包含了值并且只有满足特定条件才能解锁），也可以创建在该平台之上。这要比比特币的脚本强大的多，因为添加了图灵完备性，值感知，区块链感知和状态。

## <a id="2.1">思想（原词“Philosophy”）</a>
以太坊背后的设计目的是遵守下列规则：
1. **简单性** 以太坊协议应该尽可能简单，即使需要更多的数据存储或牺牲一些时间效率。一个正常的程序员应该能遵守和实现全部的规范。这样他才能充分领会加密货币带来的前所未有的（原词“unprecedented”）民主化潜力，进一步推动以太坊的愿景，即成为一个向所有人开放的协议。任何增加复杂性的优化只有在它提供了重大的益处时才能被包含进来。
2. **通用性** 以太坊设计思想的一个基础部分是，以太坊并没有特性。相反，以太坊提供一个内部图灵完备的脚本编程语言。程序员可以使用该语言创建任何可以数学上定义的智能合约或交易类型。想要发明自己的金融衍生品？通过以太坊，你可以。想创造自己的货币?通过以太坊合约，你也可以。想要创建全量的Daemon和Skynet（注：两个美国科幻电影中的分布式网络），你可能需要几千个联锁的合约。
3. **模块化** 以太坊协议的各部分应该设计得尽可能模块化和独立。随着开发进程，我们的目标是创建这样一个应用：如果一个人在一个地方做了很小的修改，应用栈可以继续工作而不需要额外的修改。Ethash、改版的Patricia树和RLP应该，实际也是，实现为相互独立的功能完全的库。如此一来，即使以太坊不需要某些功能，这些功能也可以用在其他协议中。以太坊开发应该最大化地完成，这样可以造福整个加密货币生态系统，而不是只是自己。
4. **敏捷性** 以太坊协议的细节并不是固定不变的。尽管我们对于上层结构的修改非常谨慎，如sharding路线图，抽象执行，数据可用性仅限于共识等。开发过程中后期的计算测试使我们发现，某些修改，如协议架构和以太坊虚拟机EVM，极大地提升了伸缩性和安全性。只要有这样的机会，我们就会采纳。
5. **无差别对待和无审查** 协议不应该主动限制或组织特定种类的用法。协议中所有监管机制都应该设计为直接管控损害，而不试图抵制特定的不期望的应用。程序员甚至可以在以太坊上运行无限循环脚本任意长时间，只要他们愿意支付每个计算步骤的交易费用。

## <a id="2.2">以太坊账户</a>
以太坊中，状态由称为“账户”的对象组成，每个账户有一个20字节的地址和账户间值和信息的直接进行转移的状态转换。一个以太坊账户包含四个字段：
  - **nonce** 一个计数器，保证每个交易只能被处理一次。
  - 账户的当前以太币余额**eth balance**。
  - 账户的合约代码**contract code**，如果有的话。
  - 账户的存储信息**storage**，默认空。

“Ether”是以太坊中主要的内部加密燃料，被用来支付交易费用。通常，有两种账户：**外部所有账户**，受私钥控制；**合约账户**，受合约代码控制。外部所有账户没有代码，你可以通过外部所有账户来创建并签名一个交易来发送消息；合约账户中，每次接收到一个消息，它的代码就被激活，允许依次读写内部存储，发送其他消息或创建合约。

注意，以太坊中的“合约”不应当被看做“应该被实现或可被编译的”；相反，它们更像存在于以太坊执行环境中的“自治代理”，即每次被消息或交易“戳”的时候总是执行特定的代码片，并且能直接控制以太币余额和保存持久变量的键/值存储。

## <a id="2.3">消息和交易</a>
术语“交易”在以太坊中用来指签名的数据包，其中存储了外部所有账户发出的消息。交易包括：
  - 消息的接收者
  - 标识发送者的签名
  - 发送者到接收者之间要转移的以太币的数量
  - 可选的数据字段
  - `STARTGAS`值，表示交易执行允许的最大的计算步骤数
  - `GASPRICE`值，表示发送者每个计算步骤的费用

前三个字段是任何加密货币都应该有的标准字段。数据字段默认没用，但虚拟机有一个操作码可以被合约用来访问数据字段。例如，如果合约被作为一个链上的域名注册服务，它可能希望把数据字段解析成两个字段：第一个字段是需要注册的域名，第二个字段是需要注册到的IP地址。合约会从消息的数据字段读取这些值并恰当地存储它们。

`STARTGAS`和`GASPRICE`对以太坊的反DOS攻击模型至关重要。为了阻止代码中偶然的，敌意的无限循环或其他的计算消耗，每个交易要求设置一个代码执行的计算步骤数量的限制。计算的基本单位是“gas”，通常，一个计算步骤消耗一个gas。但有些操作消耗更多的gas，因为它们的计算成本更高，或者是增加了状态所必须的数据量。交易中的数据每个字节费用是5 gas。费用系统的目的是促使攻击者支付与他们消耗的资源成正比的成本，这些资源包括计算，带宽和存储。因此，任何导致了网络消耗更多这些资源的交易都必须支付正比于这些消耗的费用。
## <a id="2.4">消息</a>
合约能够发送“消息”给其他合约。消息是不会被序列化的虚拟对象，只存在于以太坊的执行环境中。一个消息包含：
  - 消息发送者（隐含）
  - 消息接收者
  - 随消息一起转移的以太币数量
  - 可选的数据字段
  - `STARTGAS`值

本质上，一个消息就像一个交易。只是它由合约生成，并不是外部参与者。当当前正在执行代码的合约执行到`CALL`操作码的时候，会生成一个消息，并执行它。和交易一样，消息也会导致接收方账户执行它的代码。这样，合约就可以跟外部参与者一样，与其他合约具有完全一样的关系。

注意，交易或合约赋值的gas限额适用于本交易及所有子交易的gas花费。例如，如果外部参与者A发送了一个交易，gas是1000，B发送消息给C时消耗了600 gas，C的内部执行又消耗了300 gas，那么B在消耗完gas之前还可以花费100 gas。
## <a id="2.5">以太坊状态转换函数</a>
![](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/ethertransition.png)
以太坊状态转换函数`APPLY(S,TX) -> S'`可以定义如下：
1. 检查交易格式是否良好（即值的数量正确），签名是否有效，nonce是否与发送者账户的nonce匹配。如果不正确，返回错误。
2. 计算交易费用，`STARTGAS * GASPRICE`，从签名中确定发送地址。从发送者账户余额中减掉上面这费用，增加发送者的nonce。如果余额不足，返回错误。
3. 初始化`GAS = STARTGAS`，按每个字节减掉一定数量的gas来支付交易中的字节数据。
4. 转移交易值从发送者账户到接收者账户。如果接收者账户并不存在，创建它。如果接受账户是合约账户，执行合约代码要么直到完成要么直到gas消耗完。
5. 如果由于发送者没有足够的钱而导致交易转移失败，或者代码执行消耗完了gas，还原所有的状态改变，支付的费用除外，并把这些费用添加到矿机的账户上。
6. 否则，退还所有剩余的gas给发送者，发送消耗的gas费用给矿机。

例如，假设我们的合约代码如下：
```Serpent
if !self.storage[calldataload(0)]:
    self.storage[calldataload(0)] = calldataload(32)
```
注意，现实中，合约代码是以低级EVM代码编写的。这个例子以Serpent编写，为了清晰起见。假设合约存储起始是空的。发送了一个10以太币、2000 gas、0.001 gasprice、64字节数据（0-31字节表示数字2，32-63表示字符串`CHARLIE`）的交易后，这里的状态转换函数过程如下：
1. 检查交易有效并且格式良好。
2. 检查交易发送者至少有2000 * 0.001 = 2以太币，如果有，则从发送者账户减去2以太币。
3. 初始化gas = 2000；假设交易是170字节，每个字节费是5，则减掉850，剩下1150 gas。
4. 从发送者账户再减去10以太币到合约账户。
5. 执行代码。这里很简单：它检查合约存储下标为`2`的位置是否被使用，这里未被使用，所以它设置下标为`2`的存储位置的值为`CHARLIE`。假设这消耗了187 gas，所以剩下1150 - 187  = 963。
6. 返还963 * 0.001 = 0.963以太币到发送者账户，返回生成的结果状态。

如果在交易接收端没有合约，则总的交易费用就只是`GASPRICE`乘以交易的字节长度。随交易一起发送的数据是没有关系的。

注意，在状态还原方面，消息跟交易工作机制是一样的。如果一个消息执行消耗完了gas，那么该消息的执行以及所有该交易出发的其他执行全部还原，但更高一层的执行不必还原。这意味着一个合约调用另外一个是“安全”的，就好像A用G gas调用B，然后A的执行被保证最多消耗G gas。最后，有一个操作码`CREATE`，它可以创建一个合约，它的执行方式基本类似于`CALL`，只是执行的输出决定了新创建的合约的代码。

## <a id="2.6">代码执行</a>
以太坊合约中的代码是用低级的，基于栈的字节码语言编写的，称为“以太坊虚拟机代码”或“EVM code”。这个代码包含一系列字节，而每个字节表示一个操作。一般地，代码执行是一个无限循环，重复执行当前程序计数器指向的指令，然后将程序计数器加1直到代码结束或者错误，或者检测到`STOP`和`RETURN`指令。操作可以访问三种类型的存储空间：
  * **stack**，后进先出容器，可以允许值被压入或弹出。
  * **Memory**，可无限扩展的字节数组。
  * 合约的长期存储**storage**，key/value存储。不像stack或memory，计算结束后被重置，storage可以长期存留。

代码也可以访问进来的消息的值，发送者和数据，以及块头信息，也可以返回数据的字节数组作为输出。

EVM代码的正规执行模型是极其简单的。以太坊虚拟机运行时，它整个计算状态可以被定义为元组`(block_state, transaction, message, code, memory, stack, pc, gas)`，其中`block_state`是包含全部账户、余额和存储的全局状态。在每轮执行的开始，当前指令的计算是通过设置`pc`为`code`的值（0，如果`pc >= len(code)`），每个指令都有自己的定义如何来操作这个元组。例如，`ADD`从栈上弹出两个数据项，然后压入它们的和，减掉1 gas，然后将`pc`增加1；`SSTORE`从栈上弹出两个数据项，把第二个数据插入合约的storage中第一个数据项指定的下标中。尽管通过即时编译（原词“just-in-time compilation” ），有很多方式可以去优化以太坊虚拟机执行，但基本的以太坊实现只需要几百行代码就可以完成了。

## <a id="2.7">区块链和挖矿</a>
![](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/apply_block_diagram.png)
以太坊区块链很多方面都相似于比特币，但也有不同。不要的不同是，架构方面说来，不像比特币，以太坊block包含了交易列表和最新状态的拷贝。此外还有另外两个值，block块号和difficulty。以太坊中基本的块验证算法如下：
1. 检查引用的上一个块存在且有效。
2. 检查块的时间戳大于引用的上一个块，并且小于当前时间往后15分钟。
3. 检查块号，difficulty，交易root，uncle root（区块链中的未被采用的无效分支），gas limit有效。
4. 检查PoW有效。
5. 设`S[0]`为上一个块结束后的状态。
6. 设`TX`为块的交易列表，具有`n`个交易。对于所有的`i`，从`0...n-1`，设置`S[i+1] = APPLY(S[i],TX[i]`。如果任意应用失败，或如果总的gas消耗截止现在超过了`GASLIMIT`，返回错误。
7. 设`S_FINAL`为`S[n]`，添加块奖励给矿机miner。
8. 检查`S_FINAL`的状态树Merkle root是否等于块头中的状态root，如果是块有效，否则无效。

这个方法乍看起来很低效，每个块都要存储整个状态，但实际中效率是比得上比特币的。原因是状态存储在树结构中，生成每个块后只有很小的一部分树需要改变。因此，一般来说，相邻两个块，绝大部分都应该是相同的，因此数据可以被存储一次但被引用两次（通过hash）。一种特殊的树“Patricia树”被用来实现上述操作，它对Merkle树概念进行了修改，允许节点被高效地插入和删除，不仅仅是改变。另外，因为所有的状态信息都是最后一个block的一部分，也就没必要存储整个链的历史。这个策略如果应用到比特币，可以提供5-20倍的空间利用率。

经常问的问题是，从物理硬件角度来说，合约代码在哪执行。答案很简单：执行合约代码的过程是状态转换函数定义的一部分，它又是块验证算法的一部分。所以如果一个交易被加入到块`B`中，那么这个交易生成的代码执行（原词"code execution"）会被所有下载和验证block `B`的节点执行。

# <a id="3">应用</a>
总的来说，基于以太坊的应用有三种。第一种是金融应用，为用户提供更强大的管理和进入合约的方式来使用他们的金钱。这包括次级币（原词"sub-currencies"），金融衍生品，对冲合约，储蓄钱包，遗嘱，最后甚至某些全面的雇佣合约。第二种是半金融化应用，虽然有钱参与，但也有很重要的非金钱方面的事情。一个完美的例子就是自我约束的、计算难题的解决方案的赏金。最后，还有在线投票和去中心治理的应用，这些跟金融完全没关系。

## <a id="3.1">代币系统（原词"Tocken Systems"）</a>
链上的代币系统有很多应用，从表示美元或黄金资产的次级币到公司股票，表示智能财产的个人代币，安全的不可伪造的优惠券，甚至与传统价值毫不相关的代币系统（用在积分系统作为激励）。代币系统在以太坊中非常容易实现。关键是理解，所有的货币或代币系统，根本上都是一个执行一个操作的数据库--从A减去X单位货币，把X单位货币加到B上去。限制条件是：1）交易前A至少有X单位货币；2）交易经过A批准。实现一个代币系统其实就是在合约里实现这个逻辑。

一个基本的代币系统Serpent语言实现如下：
```Serpent
def send(to, value):
    if self.storage[msg.sender] >= value:
        self.storage[msg.sender] = self.storage[msg.sender] - value
        self.storage[to] = self.storage[to] + value
```
这本质上来说完全就是一个银行系统状态转换函数的实现。首先需要添加额外的代码来进行分发货币的初始化步骤，还有边界条件。理想情况下，需要添加一个函数让别的合约可以查询一个地址的余额。理论上，基于以太坊的充当次级币的代币系统可以包含另一个基于比特币的meta币所缺少的特性：以相同的货币里直接支付费用。实现方式是合约会维护一个以太币账户余额，这个账户余额可以被用来退还支出出去的（剩余的）交易费用，而且还可以搜集用于费用支出的（剩余的）内部本币（"currency"）在长期运营的拍卖场卖出然后充值到这个账户余额（注：第一种情况是退还剩余的“以太币”到账户，第二种是把其他“代币”在拍卖场卖出兑换成以太币然后充值到账户）。用户需要激活他们的以太币账户，但只要以太币在那就可以被重用，因为合约每次都会退还他们（剩余的）。

## <a id="3.2">金融衍生品和“稳值”货币</a>
金融衍生品是最常见的“智能合约”应用，也是最容易实现的应用之一。实现金融合约最主要的挑战是它们大部分中都要引用外部的价格提示器（原词"ticker"，愿意股票价格收报机）。例如，一个令人期待的应用是一个对冲以太币（或另外一种加密货币）对美元反复波动的智能合约，但这个合约需要ETH/USD的汇率。最简单的方式是通过一个由特定方（如NASDAQ）维护的“数据输入”合约，这样它就可以按需更新合约，并提供接口给其他合约来查询价格。

已知上述关键因素，对冲合约看起来可以这样：
1. 等待A方输入1000以太币
2. 等待B方输入1000以太币
3. 通过查询数据输入合约，把1000以太币对应美元值，比如$x记录到storage。
4. 30天后，允许A或B重新激活合约，发送等值$x美元的以太币（通过数据输入合约查询最新价格）给A，剩余的给B。

这样的合约在加密商务中有重要的应用潜力。加密货币被提及的主要问题是反复波动。尽管用户和商家可能想要安全性和便捷地处理加密资产，但他们不想面对一天可能损失资金价值的23%的场景。直到现在，最常提出的建议是发币方背书（原词"issuer-backed"）的资产。想法是，发币方创建一个他们可以创建和撤销基本单位的次级代币，然后那些提供了线下相同单位资产的人就可以被给予单位货币。并且发币方承诺每个返还单位加密资产（单位代币）的人都可以单位的线下资产。这个机制允许任何非加密资产都可以被“提升”为加密资产，前提是发币方受信任。

然而，实际上，发币方并不总是值得信任的。在有些情况下，银行基础设施要么太脆弱，要么不利于这样的服务存在。金融衍生品提供了另外一种选择。这里，不再是单独的一个发币方提供资金来支撑资产，而是一个去中心的投机者市场，打赌加密资产（如以太币）的价格会上升，这个市场充当了发币方的角色。不像发币方，投机者在交易中没有可能出现拖欠的情况，因为对冲合约把他们的资金都存在了托管账户里面。注意，尽管可以说，在基础设施要求（不像发币方，发布一个价格输入不需要执照，甚至可以被归类为自由讲话）和诈骗可能性方面，这已经提供了巨大的进步，这个方法并不是完全去中心化的，因为还是需要一个价格提供方作为受信源。

## <a id="3.3">身份和信用体系</a>
加密货币中最早的替代者，Namcoin，试图使用比特币那样的区块链来提供名称注册系统。在这个系统中，用户可以在公共的数据库中注册他们的名称以及他们数据。最常提及的例子是DNS系统，映射域名到指定IP地址。其他用例包括email认证以及可能的更高级的信用系统。这里有一个提供Namecoin那样的名称注册系统的以太坊合约：
```
def register(name, value):
    if !self.storage[name]:
        self.storage[name] = value
```
合约很简单，它就是一个以太坊网络中的数据库，可以被加入，但不可以被修改和移除。任何人都可以注册一个名称和值，然后这条注册就永远插入在那里。更复杂的名称注册合约应该也要有一个函数来允许别的合约查询它以及名称的所有者修改数据或转让所有权的机制。你甚至可以在上面添加信用和信任网络功能。

## <a id="3.4">去中心化文件存储</a>
过去的几年中，出现了一些流行的在线文件存储创业公司，最著名的就是Dropbox。它希望用户上传他们硬盘的备份，由Dropbox存储他们的备份，作为交换，允许用户免费访问一个月。但这个时候，文件存储市场有时候是相对低效的。粗略地看一下现有的解决方案发现，尤其是在“怪异谷”（原词"uncanny valley"）20-200G区间，既没有免费额度也没有企业级打折切入。主流的文件存储每月价格很高，以至于你支付的成本比整个硬盘都高。以太坊合约可以允许你开发一个去中心的文件存储生态系统，每个用户都可以通过出租自己的硬盘来赚取少量的钱，未使用的空间可以进一步降低文件存储成本。

这样一个设备的关键基础部分是我们称为的“去中心化Dropbox合约”。下面是合约的工作流程。首先它把期望的数据分成块，加密每个块数据，然后用这些块创建一个Merkle树。再创建一个合约，规则是：每N个块，合约从Merkle树中随机选择一个下标（使用上一个块的hash作为随机源），在tree的特定下标处给予X个以太币到第一个实体，来提供类似SPV的块所有权证据（证明该交易对该块的所有权）。当用户想要重复下载他们的文件，他们可以使用微支付信道协议（比如每32k一个szabo，注：一直快速支付协议）来恢复文件。最省钱的方法是支付者直到最后再发布交易，每32k数据，用相同的nonce去发起支付，这样会稍微划算一些。

这个协议的一个重要特性是，尽管这看起来像让很多随机节点不要忘记这个文件，但我们可以通过将文件分成很多份并安全共享并监控合约去查看每个文件块的存在情况来将风险降低到几乎为0。如果合约一直在支付，则正好提供了加密证据，即有人依然在存储该文件。

## <a id="3.5">去中心化自治组织</a>
“去中心化自治组织”（DAO）的一般概念是，它是一个虚拟实体，有一定数量成员或股东，他们可能有67%的大多数股份，有权花费实体的资金和修改代码。成员会一起决定组织应该如何分配他们的资金。分配DAO组织资金的方法可以是从赏金，薪资到甚至更吸引人的机制，如用内部货币作为工作奖励。这实际上复制了传统公司或非营利组织的法律陷阱，只是使用了加密区块链技术来实施。目前，对DAO的所有讨论都是围绕“去中心自治公司”（DAC，具有追求分红的股东和可交易的股份）的“资本主义”模型。一个替代选项，可以描述为“去中心自治社区”，其中所有的成员都具有相同的决策股权，并且要求全部会员的67%的同意来增加或移除会员。一个人只能有一个会员资格需要全体成员一起实施。

编写一个DAO的一般的大纲是如下。最简单的设计是一段简单的，如果2/3的成员同意修改而进行修改的自修改代码。尽管代码理论上是不可修改的，但你可以通过将代码块分布在不同的合约中并把合约需要调用的地址放在可修改的storage中，轻松地绕过并具有事实上的修改能力。这样的一个简单的DAO实现包含三种交易类型，由交易中附带的数据来区分：
  * `[0,i,K,V]`注册一个下标为`i`，修改下标`K`位置的值为`V`的提议。
  * `[0,i]`为提议`i`注册一个投票。
  * `[2,i]`最终化提议`i`，如果有足够的投票。

合约会为每个交易生成对应的语句，它保存开放的存储修改记录以及这些修改的投票列表，还会有成员列表。当所有的存储改变获得了2/3的成员投票，最终化交易会执行这个改变。更复杂的架构还会包含内置的对于发送交易和添加/移除成员的投票能力，甚至会提供代理民主（原词"Liquid Democracy"）形式的投票代理（每个人可以指定某个人为自己投票，这种指定是可以传递的。所以如果A指定B，B指定C，那么C确定了A的投票）。这个设计允许DAO有机地生长为一个去中心化社区，允许人们最终把过滤谁是会员的任务代理到专家。尽管当前系统中，专家可以因为个人社区会员改变他们的“指定”而很容易地进出。

另一种模型是“去中心化公司”，任意一个账户可以有0个或多个股份，做出决定也需要2/3的股份。完整的架构需要包括资产管理功能，报价买卖股份的能力以及接受报价的能力（合约内部最好是顺序匹配机制）。类似Liquid Democracy形式的Delegation代理泛化了“董事会”的概念。

## <a id="3.6">更多的应用</a>
1. **储蓄钱包** 假设Alice想要自己的资金是安全的但是担心自己会丢失私钥或被黑客攻击。她把自己的以太币放进了一个与Bob（银行）关联的合约，合约如下：
  * Alice每天最多可以取回1%的资金。
  * Bob每天最多可以可以取回1%的资金，但Alice有能力创建一个交易来关闭Bob的这一权限。
  * Alice和Bob一起可以取走所有钱。  
通常，每天1%对于Alice足够了，如果她想要取更多，可以联系Bob求助。如果Alice的私钥被黑了，她跑到Bob那里把钱转移到一个新的合约。如果她丢失了私钥，Bob最终可以把钱取出来。如果Bob被发现存心不良，那她可以关闭他的取款权限。  

2. **农作物保险** 你可以轻易地创建一个金融衍生品合约，基于天气的数据输入而不是任何的价格指数。如果爱荷华的农民买了一个基于爱荷华降雨量逆向赔付的衍生品，那么如果出现干旱，农民会自动收到赔付；如果雨量充沛农民会很高兴因为收成会很好。这可以扩展到普通的自然灾害保险。  

3. **去中心的数据输入** 由于金融合约的不同，它实际上可以通过称为SchellingCoin的协议实现去中心化的数据输入。SchellingCoin基本工作流程如下：N方都输入已知的每个数据（比如ETH/USD价格）的值（注：自己报价），这些值被排序，报价位于25%-75%之间的人获得一个代币作为奖励（就是说，越接近大多数人的报价就越可能得到奖励）。每个人都有动机给出一个别人也会给出的答案，大量玩家最终达成一致的值就是明显的事实上的默认值。这创建了一个去中心的协议，理论上可以给出任意数量的值，包括ETH/USD价格，柏林的温度或者甚至是某个困难的计算。  

4. **智能多重签名托管** 比特币允许多重签名交易合约，比如，五个私钥中有三个就可以花这笔钱。以太坊允许更细粒度，例如，4/5可以任意花，3/5每天最多可以花10%，2/5每天最多可以花0.5%。另外，以太坊多重签名是异步的，各方可以在不同的时间在区块链进行签名，最后一个签名（达到交易要求的法定签名数量）会自动发送交易。

5. **云计算**
EVM技术也可以用来创建一个可验证的计算环境，让用户请求其他人完成计算，然后可以向某些随机选择的检查点索要计算正确完成的证据。这允许创建一个云计算市场，而且用户可以使用他们的台式机、笔记本或定制的服务器参与进来，现场检查和安全保证金一起保证系统是值得信任的（即节点不会损害自己利益去作弊）。尽管这样的系统可能并不适合所有的任务，而且那些要求高级的进程间通信的任务在大量节点的云上也并不容易实现。但是，其他任务更容易并行化，像SETI@home和folding@home这样的项目以及遗传算法可以很容易在这样的平台上实现。

6. **P2P赌博** 任何数量的端到端赌博协议，像Frank Stajano和Richard Clayton's Cyberdice都可以在以太坊链上实现。最简单的赌博协议其实就是一个简单的赌下一个块hash有什么不同的合约，更高级的协议可以基于此来创建，这样可以几乎零费用地创建赌博服务并且无法作弊。

7. **预测市场** 如果有oracle和SchellingCoin，预测市场也很容易实现。预测市场与SchellingCoin一起可能会成为第一个主流的，管理去中心组织的Futarchy应用。

8. **链上去中心集市** 使用身份和信用体系作为基础。

# <a id="4">其他和问题</a>
## <a id="4.1">修订版GHOST实现</a>
Ghost协议（原词"Greedy Heaviest Observed Subtree"）最初是由Yonatan Sompolinsky和Aviv Zohar在2013年12月发明的。提出Ghost的原因是，区块链由于过快的确认时间而变得不再安全--block淘汰率变得很高。因为block在网络中传播需要一定的时间，矿机A挖了一个块，然后B碰巧在A的块广播到它之前挖了另外一个块，则矿机B挖的块最终会浪费掉，对网络安全并没有用处。另外还有中心化问题：如果A是一个有30%hash算力的挖矿池，B有10%，则A可能70%的时间都在生成最终被废弃的块（因为另外30%的时间能挖到块）而B则可能90%的时间也都在生成最终被废弃的块。因此，如果块间隔太低以至于淘汰率太高，A总体上会因为自己的算力大小而更高效。考虑到上面的两个因素，生成块速度过快的区块链很可能导致一个挖矿池占有很大一部分的比例的网络hash算力，对挖矿进程形成事实上的控制权。

正如Sompolinsky和Zohar所描述的，Ghost通过把废弃的块也包含到“最长链”的计算中来解决第一个网络安全受损问题。就是说，最长的总的PoW计算，不单单只有父块以及更早的祖先块，还包括废弃的、块的祖先的后代块（以太坊术语，“叔块”）。为了解决中心化倾向问题，我们跨过了Sompolinsky和Zohar的协议，向废弃块也提供奖励。废弃块能得到正常块奖励的87.5%，包含废弃块的“侄子”节点得到剩余12.5%的奖励（注：就是链的分叉处，最终更长的链称为主链，另一个就是被废弃的叔链。分叉处第一个块称为叔块，下一个块就是“侄子”块。当然如果你把第一个块称为“姐块”，那下一个块就是“外甥”块。意思就是说，第一个叔块在网络中存在时间更长，为网络做贡献更多所以给予奖励也稍微更多倾斜）。但是，交易费并不奖励给叔块。

以太坊实现了一个简化的Ghost协议，只有7个层级。具体如下：
  * 块block必须指定父块，以及0个或多个叔块。
  * B块（主链）包含的叔块必须具有如下属性：
    * 它必须是B的第k代祖先的直接子块， 2<=k<=7。
    * 它不能是B的祖先。
    * 叔块必须有一个有效的块头header，不需要被验证过或是有效的block。
    * 叔块必须不同于之前的block已经包含的所有的叔块，或者本块包含的所有其他叔块。（禁止重复包含）
 * 对于B块的每个叔块U，矿机B获得额外的3.125%奖励，U获得93.75%标准块奖励。

使用这个受限版本的Ghost，被包含的叔块只能往前追溯7代，主要有两个原因。首先，无限制的Ghost包含了太多计算某个块的叔块是否有效的难题。其次，正如以太坊中使用的，无限制的Ghost的补偿机制取消了对矿机在主链上进行挖矿的激励，反而激励公共攻击者的链。

## <a id="4.2">费用</a>
因为发布到区块链中的交易都需要网络下载和验证它，所以需要一些监管机制防止过度使用，典型地是交易费用相关（的监管）。比特币中默认的方法是，完全自愿地付费，依赖于矿机充当守护者并设置动态的最小值。这个方法非常顺利地被比特币社区接受，主要是因为他是“基于市场”的，允许挖矿者和交易发送者供需双方决定价格。但是，这个推断的存在问题是交易处理并不是市场机制。尽管把交易处理解释成--挖矿者提供给发送者的服务--直觉上很吸引人，但实际上矿机包含的每个交易都需要经过网络中的每个节点的处理，所以大部分的交易处理消耗都是由第三方节点完成的，而不是决定要不要包含该交易的块的矿机。因此，“众人悲剧”（原词"tragedy-of-commons"，类似三个和尚没水喝）很可能发生。

但从实际效果看，这个缺陷如果被给予特定的不准确的简化假设时，在市场机制中神奇地消失了。理由如下：
1. 一个交易产生k个操作，提供kR个奖励给矿机。R由发送者设置，并且k和R对矿机是事先可见的。
2. 每个操作的处理成本是C。
3. 有N个挖矿节点，每个的处理能力几乎相同。
4. 没有其他的非挖矿全量节点。

如果交易的奖励超出处理的成本，挖矿者就愿意处理它。预期奖励是kR/N而节点的处理成本是kC（每个节点都需要处理全部的交易）。因此，矿机在kR/N>kC，即R>NC时愿意挖矿记录交易到块中。注意R是发送者指定的每个交易的处理费用，因此也就是发送者能够从交易中获利的最低边界，而NC是整个网络处理一次操作的成本。因此，矿机有兴趣挖矿记录那些实际总收益超过处理成本的交易到块中。

然而实际中有几处重要的不同于假设的差异点：
1. 挖矿节点支付的交易处理成本并不比其他验证节点高。因为额外的验证时间拖延了块的广播，因此增加了它被废弃的机会。
2. 确实有非挖矿全量节点。
3. 挖矿力分布最终会完全不平等。
4. 投机者，政治对手以及疯子确实存在，他们聪明地配置他们的合约，使成本比其他验证节点低得多。

(1)让矿机情愿包含更少的交易；(2)增加了NC，因此这两个效果至少部分地相互抵消了。(3)和(4)是主要的问题，为了解决这两个问题，我们简单地设置了一个浮动的限制：任何块最多能处理BLK_LIMIT_FACTOR乘以长期指数滑动平均值。特别地：
```
blk.oplimit = floor((blk.parent.oplimit * (EMAFACTOR - 1) + floor(parent.opcount * BLK_LIMIT_FACTOR)) / EMA_FACTOR)
```
BLK_LIMIT_FACTOR和EMA_FACTOR是常量，当前分别为65536和1.5（将来可能会变化）。

另一个没有促使比特币使用大的block size的原因是：大的block广播需要更长的时间，因而更可能变成废弃块。以太坊中，gas消耗较高的block也可能需要更久的广播时间，因为它们的数据量更大也是因为验证这些交易需要更长的时间。这个延迟在比特币中是一个重要的考虑点，但以太坊由于使用了Ghost协议，这个问题并不太重要。因此依赖于对块限制的监管，我们才有了更稳定的基础。

## <a id="4.3">计算以及图灵完备性</a>
需要重点注意的是以太坊虚拟机是图灵完备的，即EVM代码可以编码任何能够实现的计算（包括无限循环）。EVM允许两种形式的循环：第一种，存在JUMP跳转指令跳转到之前的代码点或JUMPI进行有条件跳转，如`while x < 27: x = x * 2`；第二种，合约能调用别的合约，潜在地允许通过递归进行循环。这自然就导致一个问题--恶意用户完全关闭矿机和全量节点迫使它们进入无限循环。这个问题的出现是由于计算机科学中称为“停机问题”：通常情况下，没有办法知道给定的程序是否会停机。

就像状态转换小节所讲的，我们的解决方案是为每个交易设置一个允许执行的最大的计算步骤数。如果执行中超过了这个数，则计算还原但费用不会退还。消息的工作方式也一样。为了说明我们的解决方案的动机，考虑下面的例子：
  * 攻击者创建了一个无限循环合约，然后给矿机发送一个交易激活它。矿机处理这个交易，执行无限循环，等待它耗完gas。尽管执行过程会消耗完gas而中途停止，但交易依然是有效的而且矿机向攻击者收取了每一个计算步骤的费用。（注：目的是，即使是恶意的代码，也能优雅地执行）
  * 攻击者创建了一个非常长的无限循环，目的是让矿机一直忙于计算等到计算结束的时候已经由其他的块生成了从而导致该矿机不能包含该交易进而收取相应的费用。但是，攻击者需要提供一个STARTGAS值来限制可以执行的计算步骤的数量，这样矿机就会提前知道这次计算会需要长得多的计算步骤。
  * 攻击者看到形如`send(A,contract.storage[A]); contract.storage[A] = 0`的合约，然后发送一个交易而其中的gas恰好只够第一步执行（好比只取款但账户余额不变），合约作者不需要担心这样的攻击，因为如果执行中途停止，那么之前作出的改变会被还原。
  * 金融合约通过采纳9个专门的数据输入的中值（median）来降低风险。攻击者控制了其中一个数据输入，正好是可以通过变量地址调用进行修改（参考DAO小节）的那个，把它转变成无限循环，以此让任何试图从合约中提取资金的尝试都耗完gas（而无法提取到资金）。但是，金融合约可以在消息里面设置gas limit来避免这个问题。

图灵完备的另一个选择是图灵不完备，即没有JUMP和JUMPI，任何时间一个合约只能有一个拷贝在调用栈中存在。根据这个系统，描述的费用系统和我们的解决方案有效性的不确定性就显得并不是必要的，因为执行一个合约的花费会被它自身的大小限制上限。另外，图灵不完备也不算太大的限制。所有的我们内部能想出的合约中，只有一种需要循环，而且这个循环可以通过26次重复调用单行代码代替。已知图灵完备性的重要的暗示以及有限的收益，为什么不选择图灵不完备语言呢？然而，实际中，图灵不完备远谈不上算是一个好的解决方案。考虑下面的合约：
```
C0: call(C1); call(C1);
C1: call(C2); call(C2);
C2: call(C3); call(C3);
...
C49: call(C50); call(C50);
C50: (run one step of a program and record the change in storage)
```
发送一个交易给A，则51个交易之后，我们的合约需要2<sup>50</sup>计算步骤。矿机会通过维护一个每个合约携带的一个限定自己可以执行的最大计算步骤数的值（STARTGAS）来尽量提前检测这样的逻辑炸弹，以及计算递归调用其他合约的合约的数量，但这要求矿机禁止那些创建新合约的合约执行（因为创建和执行上面所有的26个合约可以很轻易地合并到一个合约）。另一个问题点是消息的地址字段是变量，所以一般来说可能没办法提前知道给定的合约会调用哪些别的合约。因此，总而言之，我们有一个惊喜的结论：图灵完备是及其容易管理的，而缺少图灵完备的管理也是同样极其困难的，除非施加完全相同的控制，但那样的话干嘛不让协议变成图灵完备呢？

## <a id="4.4">货币和发行</a>
以太坊网络包含了自己的内置货币--以太币，它的两个目的是：提供流动层，使各种类型的数字资产可以高效的交换；更重要的是，作为一种支付交易费用的机制。为了方便以及避免将来的争论（参考比特币中mBTC/uBTC/satoshi的争论），这里把面额提前标记如下：
  * 1：wei
  * 10<sup>12</sup>: szabo
  * 10<sup>15</sup>: finney
  * 10<sup>18</sup>: ether

这可以看做是“美元”，“美分”，“BTC”或“satoshi”的扩展版本。在不久的将来，我们期望“以太币”被用于普通交易，“finney”被用于微交易，“szabo”和“wei”用于围绕费用和协议实现的技术讨论。其他的面额可能将来会有用，但当前并不应该包含到客户端。

发行模型如下：
  * 以太币的发行价是1000-2000以太币/BTC，目的是为以太坊组织筹集资金支付已经被Mastercoin和NXT等其他平台成功应用的开发费用。早期的买家会有更大的优惠。销售收到的BTC将全部用于支付开发者的工资和赏金以及以太坊和加密货币生态系统中的盈利和非盈利项目。
  * 0.099x 总的销售数量（60102216以太币）会被分配给以太坊组织用于补偿早期的贡献者以及支付以以太币计价的创世块之前的开销。
  * 0.099x 总的销售数量会被预留作为长期使用。
  * 每年0.26x 总的销售数量会被永久分配给矿机。

背景知识：2014年7月24日起，以太坊团队进行了为期42天的以太币预售，一共募集到31,531个比特币，等值共计60,102,216个以太币。上面的x就是60,102,216。预售前两周发行价格是2000 ether/BTC，每周递减，最后一周是1337 ether/BTC。以太坊正式发行时实际有x + x * 0.099 * 2 = 1.198x = 72,002,454个以太币。每年0.26x=15,626,576个以太币被挖出。一两年后，工作证明机制由PoW转向PoS之后，每年产出的以太币将大为减少，甚至可以不再增发新币。

Group | 项目启动时| 一年后| 5年后
 -- | -- | -- | --
货币单位|	1.198X	|1.458X	|2.498X
购买者	|83.5%	|68.6%	|40.0%
Reserve spent pre-sale|	8.26%|	6.79%|	3.96%
Reserve used post-sale	|8.26%	|6.79%	|3.96%
矿机	|0%	|17.8%	|52.0%

长期供应增长率  

图表说明：正式发行时为x+0.099x+0.099x=1.198x，第二年为1.198x+0.26x=1.458x，第5年为1.198x+0.26x * 5=2.498x。矿机比例第一年为0.26x/1.458x=17.8%，第5年为0.26x * 5/2.498x=52%。

![](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/inflation.png)

尽管货币是线性发行，但就像比特币，随着时间的增长，增长率趋向于0。

上面模型的两个主要选择点是：(1)捐赠资金池的存在和大小；(2)与比特币限制供应相反的永久增长的线性供应的存在。捐赠池存在的理由是：如果捐赠池不存在且线性发行降低到0.217x来提供相同的通胀率，那么总的以太币数量会少16.5%，因此每个单位会增值19.8%。所以，在均衡系统中，19.8%的以太币需要被回购，这样每单位价值就可以回到之前。组织也会有1.198x等值的BTC，被分为两部分：原始的BTC，额外的0.198x。因此，这种情况完全等效于捐赠，但有一点不同：组织只存有BTC，这样就不会推高以太币单位价值。

永久的线性增长供应模型降低了一些人在比特币中看到的财富过度集中问题的风险，使个人不管是现在还是将来都有公平的机会获取货币单位，同时由于“供应增长率”以百分比计随着时间会趋近于零而又能保持较强的动力去获取和持有以太币。同时我们推断，coins总是会由于无心而丢失或者死亡并且coin丢失可以建模为每年总供应量的百分比值，那么总的循环货币供应实际上最终会稳定在每年发币量除以丢失率这样一个值（例如，丢失率1%，一旦供应达到26X，那么每年0.26X会被挖出，0.26X被丢失，刚好达到平衡）。

注意，将来以太坊可能转换到proof-of-stake安全模型，使发币需求降低到每年0-0.05X。如果以太坊组织失去资金或者因为其他原因而消失，我们开放了一个“社会合约”：每个人都有权创建一个未来的以太坊候选版本，唯一条件是以太币的数量最多等于`60102216 * (1.198 + 0.26 * n)`，其中`n`是从创世块算起的年份。创建者可以任意选择向大众出售或分配部分或全部的PoS驱动的供应扩张与允许的最大供应扩张之间的差值来支付开发费用。不遵守“社会合约”的候选更新版本理所应当被归类到兼容版本。

## <a id="4.5">挖矿中心化</a>
比特币挖矿算法是通过稍微修改block header来重复上百万次地计算SHA256，直到有一个节点提出一个小于目标值的hash（当前是2<sup>192</sup>）。但是这种挖矿算法对于下面的两类中心化问题来说是很脆弱的。第一种，当前的挖矿网络已经被ASIC（应用特定的集成电路，注：SHA256计算消耗特定硬件）支配了，这种芯片在比特币挖矿这样的特定任务上的效率要高出几千倍。这意味着比特币挖矿不再是一个去中心的、平等的追求，而是需要投入上百万资金才能参与。第二种，大部分的比特币矿机并不在本地执行验证，而是依赖一个中心化的矿池来提供块头。这个问题甚至更严重：在写作本文的时候，前三名的矿池间接控制了比特币网络中大约50%的处理能力，尽管矿机可以在一个矿池或联盟试图进行51%攻击时切换到其他矿池来缓解该问题。

当前以太坊的意图是使用一个挖矿算法，这个算法需要矿机从状态中获取随机数据，然后从区块链中最近的N个block中随机选择一些交易进行计算，最后返回计算的结果hash。这有两个重要的好处：首先，以太坊合约可以包含任意类型的计算，所以以太坊的ASIC最终会变成通用计算的ASIC；其次，挖矿要求访问整个区块链，强迫矿机存储整个区块链，至少能够验证每笔交易。这样就不再需要中心化矿池。尽管矿池依然可以扮演合法的角色来平均化奖励分布的随机性，但这个功能同样可以通过没有中心控制的P2P池来完成。

这个模型没有经过试验，而且当使用合约执行来作为挖矿算法时避免某些精巧的优化可能会很困难。然而，这个算法的一个非常有意思的特性是，它允许任何人“给井里投毒”，即引入大量的特别设计地用于阻碍某些ASIC的合约到区块链中。对于ASIC生产商来说，存在利益驱动去使用这样的手段来攻击别人。因此，我们正在开发的解决方案最终将会是一个自适应的经济的人工干预解决方案，而不是纯技术方案。

## <a id="4.6">伸缩性</a>
以太坊一个常见问题是伸缩性问题。就像比特币，以太坊也有每个交易都要被网络中每个节点处理的缺点。对于比特币，当前区块链大小为大约15G，每小时增长1M。如果比特币网络用来处理Visa的每秒2000笔交易，那么它每3秒就会增长1M（每小时1G，每年8T）。以太坊也有相似的增长模式，更糟的是以太坊上面可能有很多应用，而不只是比特币那样一种货币。但稍微好一点的是，以太坊中每个全量节点只需要存储状态信息而不是整个区块链历史。

区块链巨大的空间问题是一个中心化风险。如果区块链大小增长到，比如100T，那么可能的场景就是只要少量的商业机构才能运行全量节点而普通的用户只能成为轻量的SPV节点。这种情况下，可能出现的问题是全量节可能联合起来并以对自己有利的方式一致作弊（比如改变块奖励，给自己BTC）。而轻量节点没有办法立即感知。当然，可能至少有一个诚实的全量节点存在，几个小时后，这些欺骗信息会通过Reddit（新闻网站）这样的渠道慢慢流出，但已经为时已晚。应该由普通用户组织力量将这些块加入黑名单--一个巨大的而且几乎不可行的如此规模的协调问题--导致了51%攻击的成功。比特币中当前存在这个问题，但有一个Peter Todd提出的修改版本区块链可以缓解这个问题。

短期来看，以太坊会使用两个额外的策略来解决这个问题。首先，由于基于区块链的挖矿算法，每个矿机只要都要强制成为一个全量节点，这确定了一个全量节点数量的下界；其次也是更重要的是，每个交易处理完后我们会包含中间状态树根root。即使块验证是中心化的，只要有一个诚实验证节点存在，中心化问题就可以通过验证协议来避免。如果矿机发布了一个无效的块，那么这个块要么格式不对要么状态`S[n]`错误。因为`S[0]`被认为是正确的，，那么肯定有第一个错误的状态`S[i]`。验证节点会提供下标`i`以及包含了处理`APPLY(S[i-1],TX[i]) -> S[i]`所需的Patricia树节点子集的无效证明。节点可以使用这些节点执行该部分计算，并验证生成的`S[i]`与提供的`S[i]`是不相符的。

另外一个更复杂的攻击是恶意的矿机发布不完整的块，则根本没有全部的信息来确定块是否有效。该问题的解决方法是“挑战相应协议”：验证节点以目标交易下标的形式发布“挑战”，当轻量节点收到之后认为这个块是不可信的直到另外一个节点，矿机或验证者提供了Patricia节点子集作为有效证明。

# <a id="5">结论</a>
以太坊协议最初构想为一个升级版加密货币，提供像链上托管，取款限制，金融合约，赌博市场以及高度泛化的编程语言等高级特性。以太坊协议不会直接支持任何应用，但是图灵完备编程语言的存在意味着任意交易类型或应用的任意合约理论上都是可以创建的。然而，以太坊最有意思的是，以太坊协议已经远远不只是货币了。围绕去中心化文件存储、去中心化计算、去中心化预测市场以及其他很多类似概念的协议有潜力极大地增加计算产业的效率，并且通过增加一个经济层给其他P2P协议带来巨大的提升。最后，还有大量的跟钱毫无关系的应用。

以太坊协议实现的任意状态转换函数的概念提供了一个具有独特潜力的平台。它不是一个针对特定一批数据存储、赌博或金融应用的，封闭的、单目的的协议，以太坊是一个开放设计的，我们相信它非常适合作为未来几年出现的大量金融和非金融协议的基础层。

# <a id="6">备注及进一步阅读</a>
## <a id="6.1">备注</a>
1. 有经验的读者会注意到实际上比特币地址就是椭圆曲线的公钥的hash而不是公钥本身。但是实际上把公钥hash称为公钥完全是合法的加密术语。这是因为比特币加密可以被认为是一个自定义的数字签名算法，而公钥包含了ECC公钥hash，签名包含了ECC公钥和ECC签名，验证算法包括检查签名中的ECC公钥与ECC公钥hash是否一致，然后验证ECC签名和ECC公钥是否匹配。
2. 以太坊协议应该简单又实用，但是有可能有些方面就比较复杂，比如规模，内部化存储、带宽和I/O成本来实现安全、隐私和透明等。比较复杂的地方，文档尽量清晰，简洁并保持最新，这样没完全没上过学的人在以太坊中也可以学会，成为专家。
3. 查看以太坊虚拟机EVM黄皮书，尽管以太坊wiki也有很多话题资料，比如实现和网络协议。对于研究和将来可能的实现，请看[ethresear.ch](https://ethresear.ch)。而[第一阶段分片路线图](https://ethresear.ch/t/sharding-phase-1-spec/1407/67?)包含了未来几年以太坊2.0可能的改变。 
4. [最新的路线图](https://ethresear.ch/t/sharding-phase-1-spec/1407/67)计划抽象执行，允许执行引擎不必遵守标准规范，而是可以为特定应用做裁剪。
5. 在以太坊内部，2和CHARLIE都是数字，后者是big-endian大端256位表示。数字最小可以是0，最大2<sup>256</sup>-1。

## <a id="6.2">进一步阅读</a>
1. Intrinsic value: http://bitcoinmagazine.com/8640/an-exploration-of-intrinsic-value-what-it-is-why-bitcoin-doesnt-have-it-and-why-bitcoin-does-have-it/
2. Smart property: https://en.bitcoin.it/wiki/Smart_Property
3. Smart contracts: https://en.bitcoin.it/wiki/Contracts
4. B-money: http://www.weidai.com/bmoney.txt
5. Reusable proofs of work: http://www.finney.org/~hal/rpow/
6. Secure property titles with owner authority: http://szabo.best.vwh.net/securetitle.html
7. Bitcoin whitepaper: http://bitcoin.org/bitcoin.pdf
8. Namecoin: https://namecoin.org/
9. Zooko's triangle: http://en.wikipedia.org/wiki/Zooko's_triangle
10. Colored coins whitepaper: https://docs.google.com/a/buterin.com/document/d/1AnkP_cVZTCMLIzw4DvsW6M8Q2JC0lIzrTLuoWu2z1BE/edit
11. Mastercoin whitepaper: https://github.com/mastercoin-MSC/spec
12. Decentralized autonomous corporations, Bitcoin Magazine: http://bitcoinmagazine.com/7050/bootstrapping-a-decentralized-autonomous-corporation-part-i/
13. Simplified payment verification: https://en.bitcoin.it/wiki/Scalability#Simplifiedpaymentverification
14. Merkle trees: http://en.wikipedia.org/wiki/Merkle_tree
15. Patricia trees: http://en.wikipedia.org/wiki/Patricia_tree
16. GHOST: https://eprint.iacr.org/2013/881.pdf
17. StorJ and Autonomous Agents, Jeff Garzik: http://garzikrants.blogspot.ca/2013/01/storj-and-bitcoin-autonomous-agents.html
18. Mike Hearn on Smart Property at Turing Festival: http://www.youtube.com/watch?v=Pu4PAMFPo5Y
19.Ethereum RLP: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-RLP
20. Ethereum Merkle Patricia trees: https://github.com/ethereum/wiki/wiki/%5BEnglish%5D-Patricia-Tree
21. Peter Todd on Merkle sum trees: http://sourceforge.net/p/bitcoin/mailman/message/31709140/
