# 下一代智能合约及去中心化应用平台
中本聪2009开发的比特币是第一种没有实物支撑或内在价值，没有中心发行者的数字资产。比特币中实现分布式共识的底层区块链技术很快吸引了大家更多的注意力。经常提到的区块链应用包括：使用链上数字资产表示自定义的货币及金融工具（colored coin），底层物理设备的所有权（smart property），不可替代资产如域名（Namecoin）以及更复杂的应用，包括实现任意规则的代码直接控制的数字资产（smart contract）或者基于区块链的去中心化自治组织（DAOs）。Ethereum打算提供的是一个内置成熟的图灵完备的编程语言的区块链，这种编程语言可以用于创建合约，用来编码任意的状态转换函数，允许用户创建以上提到的任何系统以及很多其他的暂时想不到的。<font color=red>(注：从这里看出，以太坊的作者希望整合当时各种分布式代币系统的特性，建立一个通用的、具有图灵完备的智能合约编程语言的分布式应用平台)</font>


# 目录
- 比特币及现有概念介绍
  - 历史
  - 比特币中的状态转换系统
  - 挖矿
  - Merkle树
  - 其他区块链应用
  - 脚本编程
- 以太坊（Ethereum）
  - 思想
  - 以太坊账户
  - 消息和交易
  - 消息
  - 以太坊状态转换函数
  - 代码执行
  - 区块链和挖矿
- 应用
  - 代币系统
  - 金融衍生品及稳值货币
  - 身份和信用体系
  - 去中心化文件存储
  - 去中心化自治组织
  - 更多的应用
- 其他及问题
  - 改进的GHOST实现
  - 费用
  - 计算和图灵完备
  - 货币和保险
  - 挖矿中心化
  - 伸缩性
- 结论
- 备注及进一步阅读

# 比特币及现有概念介绍
## 历史
去中心化数字货币以及其他应用像财产登记已经存在几十年了。1980和1990年代的匿名电子现金协议，主要依赖于类似乔母盲签（Chaumian blinding）等加密原语，提供了一种高度隐私的货币，但由于对中心化中介机构的依赖使得它没有受到普遍欢迎。1998年，戴伟的b-money成为第一个引入通过解决计算难题及去中心化共识来发币的主意的提议。但他的提议缺少去中心化共识如何实现的细节。2005年，Hal Finney引入了“可复用工作量证明”的概念，该系统借鉴了b-money以及Adam Back的计算困难的Hashcash难题，但依然依赖于可信计算作为后端支持。2009年，中本聪（Satoshi Nakamoto）第一次真正实现了去中心化货币，他结合了通过公钥加密来管理所有权的原语及跟踪币的流动的共识算法（称为“工作量证明proof of work”）。
工作量证明机制是该领域的一个突破，因为它同时解决了两个问题。第一，它提供了一个简单但又相对有效的共识算法，允许网络中的节点一起表决一组公认的比特币账本状态更新；第二，它提供了一个机制，允许自由进入共识过程，解决了谁可以影响共识的政治问题，同时阻止了女巫攻击。能阻止攻击的原因是它为每个参与的节点设置了一个门槛，比如要求注册成唯一的实体，加入经济因素的门槛--每个节点的投票权重正比于节点自身的计算力。之后，另一种称为proof of stake的方法被提出来，它计算每个节点的权重正比于该节点的持币量，而不是计算资源。
## 比特币中的状态转换系统
![](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/statetransition.png)
从技术角度来说，比特币这样的加密货币账本可以被看做一个状态转换系统。其中“状态”包含所有现存比特币的所有权状态，“状态转换函数”输入一个状态和交易并输出新的状态结果。例如，在标准的银行系统中，状态就是余额表，交易就是从A转移$X到B的请求，而状态转换函数从A账户减去$X并向B增加$X。如果A最初就没有$X那么多，状态转换函数就返回错误。形式上可以做如下定义：
```go
APPLY(S,TX) -> S' or ERROR
上面的银行系统中：
APPLY({ Alice: $50, Bob: $50 },"send $20 from Alice to Bob") = { Alice: $30, Bob: $70 }
或者
APPLY({ Alice: $50, Bob: $50 },"send $70 from Alice to Bob") = ERROR
```
比特币中的“状态”是所有已挖出但未消费的比特币的集合（技术上称为“未花费交易输出”，即UTXO），其中每一个UTXO都有一个面额和所有者。一个交易可以有多个输入和一个或多个输出，每个输入都引用了一个UTXO和私钥加密签名，而每个输出都包含一个UTXO并被加入到“状态”中。
状态转换函数APPLY(S,TX) -> S'可以大致被定义为：

1. 对于每一个输入Tx：  
    * 如果引用的UTXO不在S中，返回错误。  
    * 如果提供的签名与UTXO的所有者不匹配，返回错误。
2. 如果所有输入的UTXO的面额总额小于所有输出UTXO的面额总额，返回错误。  
3. 移除所有的输入UTXO，增加所有输出UTXO，返回S'。  

举例来说，Alice要向Bob转11.7比特币。首先，Alice先查找她拥有的总额不少于11.7比特币的可用的一组UTXO。实际情况，Alice可能并不能正好获得11.7比特币，比如，可能获取到最低可用的6+4+2=12比特币。她然后创建以这三个UTXO作为输入和两个输出的交易，第一个输出是Bob作为所有者的11.7比特币，第二个输出是剩下的0.3个比特币“零钱”，所有者是Alice。
## 挖矿
![](https://raw.githubusercontent.com/ethereumbuilders/GitBook/master/en/vitalik-diagrams/block.png)
如果有值得信任的中心化服务，这个系统会很容易实现，使用中心化服务器保存状态即可。但比特币是一个去中心化系统，为了确认每个交易的顺序，需要把状态系统跟共识系统联合在一起。比特币去中心化共识过程要求网络中的节点持续地生成交易包，称为“block”。这个网络期望是大概每10分钟生成一个块，其中包含了时间戳，nonce，上一个块的hash以及上一个块之后发生的所有交易列表。这样，长时间之后，就构成了一个“区块链”，并持续更新来表示最新的比特币账本状态。
检查一个block是否有效的算法如下：  
1. 检查上一个block存在并且有效。  
2. 检查block的时间戳，大于上一个block并且小于未来两小时。  
3. 检查block的工作量证明是有效的。  
4. 设S[0]为上一个块结束后的区块链状态。  
5. 假设TX是本块的n个交易的列表，对于其中任意的第i个从0到n-1的交易有S[i+1] = APPLY(S[i],TX[i])，如果任意APPLY出错，退出并返回false。  
6. 返回true，并记录S[n]为当前块的结束状态。  

本质上，块中的每个交易都要提供一个有效的状态转换，从交易执行前的标准的状态到新的状态。这个状态可以从创世块genesis状态顺序执行每个块中的每个交易计算得到。另外，矿机包含交易到块中的顺序的先后是影响的。如果交易B花费的UTXO是被A创建的，则交易A在B之前block才是有效的。  

上面列表中的验证条件中其他系统所没有的是“工作量证明”的要求。准确来说就是每个块的double-SHA256 hash（256位数字），必须小于一个动态调整的目标值，编写该文档时大约是2^187。这样做的目的是让块的创建变得计算困难，因此阻止恶意攻击来篡改这个链。因为SHA256是一个完全不可预测的伪随机函数，创建有效块的唯一方式是简单的尝试、失败，然后重复增加nonce并计算新的hash是否匹配。

以现在的目标值\~2^187，网络需要大概\~2^69次尝试才能生成一个有效的块。通常，这个目标值每经过2016个块都会重新调整，保证每个新的块在网络中的生成速度平均在10分钟左右。为了补偿挖矿节点付出的计算工作，每个块的挖出节点都有权包含一个交易来凭空给予自己12.5个比特币。如果任何交易中所有输入的面额高于输出，差值也会被给予挖矿节点作为“交易费”。另外，这也是BTC发币的唯一机制，创世块genesis根本不包含币。

为了更好理解挖矿的目的，我们检查一下有恶意攻击者时会发生什么。因为比特币底层的加密被认为是安全的，攻击者会将目标定为比特币系统中没有加密直接保护的部分：交易顺序。攻击者的策略很简单：  
1. 发送100 BTC给商户，交换一些商品（最好是能快速发货的数字产品）。  
2. 等待商品发货。  
3. 生成另外一个交易，再把这100 BTC发送给自己。  
4. 设法使网络相信他的发送给自己100 BTC的交易先于发送出去的交易。  

一旦第一步完成，几分钟后，一些挖矿节点就会包含交易到块中，比如block 270。一小时后，后续的5个块会被包含进链中，这些block都间接指向这个交易并对其“确认”。这时，商户会最终接受到这笔支付，然后发货。因为是数字产品，我们假设可以立即发货。现在攻击者创建另外一个交易，转发100 BTC给自己，如果简单发送这个交易到网络中，交易并不会被处理。矿机会尝试执行APPLY(S,TX)然后发行TX消费的UTXO并不在“状态”（账户余额）中。所以，攻击者就创建一个链的“分支”，从挖另一个版本的block 270开始，指向上一个block 269，同时用新的交易（给自己转100 BTC）替代旧的交易（给商户转出100 BTC）。由于块数据不同，需要重新计算“工作量证明”。另外，攻击者新版本的block 270的hash也不同于原始链，所以原始链中的block 271-275并不指向它，因此原始链和攻击者的新链是完全分开的。规则是：分支中最长的链被接受为事实，即认为是主链。所以，合法的挖矿者会在block 275上开始工作，而攻击者会独立工作在自己新的分支上。攻击者为了使自己的分支变得最长，他需要有比所有的剩余网络节点更多的计算能力才能“追上”，即“51%攻击”。
## Merkle树
![](https://raw.githubusercontent.com/ethereum/www/master-postsale/src/extras/gh_wiki/spv_bitcoin.png)  
左侧：只需要展示Merkle树中一小部分节点就可以证明一个分支的有效性。（**快速验证特性**）  
右侧：任何尝试改变Merkle树任何部分最终都会导致链上更高层某个地方的不一致。（**难以篡改特性**）  

比特币一个重要的伸缩特性就是block被存储在一个多层数据结构（Merkle Tree）。一个块的hash其实只是该块的头部header hash，大约200字节的数据块，包含了时间戳timestamp，累加器nonce，上一个块hash和存储了所有交易的Merkle树的根hash。Merkle树是一种二叉树，其中大量节点是最底层的包含了交易数据的叶子节点，剩余的中间节点每个节点是两个子节点的hash，还有一个“最顶层的中间节点”，称为root根节点。使用Merkle树的目的是允许块中的数据可以零碎地被发送（复制）：一个节点可以从一个地方只下载block header信息，然后从另外一个地方下载与该块相关的部分信息，然后确认该部分数据是正确的。原因是，hahs向上扩散：如果恶意用户尝试替换假的交易到Merkle树的底部，这样会改变上层节点，然后依次的上层节点，最终改变root节点以至于block hash。这会使比特币把它当成一个不同的块（几乎可以肯定PoW是无效的）。

Merkle树协议应该说对长期可持续来说是必不可少的。比特币网络中的“全量节点”存储和处理完整的每个块，占用大概15G（2014年4月），每月大概增长1G。当前，对于某些桌面电脑来说是可行的，但手机不行，将来只有商业用户和爱好者能参与。一种称为“简化支付验证”（SPV）的协议允许另一类节点的存在，称为“轻量节点”，它们下载block header，基于header验证PoW，然后只下载与这些block的交易相关的“分支”。这样，“轻量节点”就能以较强的安全保证来确认任何交易的状态和当前余额，而这只需要下载整个区块链中非常小的一部分就可以了。
## 其他比特币应用
采用底层的区块链想法并应用到其他概念中同样有很长时间了。1998年，Nick Szabo提出了“用户授权的安全房产证明”的概念，里面描述了新的可复制数据库技术的进步可以存储土地所有权信息到基于区块链的系统。他创造了复杂的框架，包含如宅基地，非法占用和佐治亚土地税等概念。但是当时并没有有效的可复制数据库技术，直到2009年比特币的去中心化共识机制被引入，其他类似应用才快速出现。  

  * **Namecoin** 创建于2010年。Namecoin被描述为一个去中心的名称注册数据库。在去中心化协议中，如比特币，Tor和BitMessage，需要有种方式来标识账号。当前已有的系统中，都是伪随机hash，如1LW79wp5ZBqaHW1jL5TCiBCrhQYtHagUWy， 但大家希望有一个易记的如“george”名字。但这样的名字又容易重复及被伪造，那么唯一的方案就是申请在先的原则，先申请成功后申请失败。Namecoin是类似想法中，最早的也是最成功的名称注册系统。
  * **Colored coins** colored coins（“彩币”）的目的是作为一个协议允许人们创建自己的数字货币，或者在比特币链上的数字代币。在“彩币”中，每个人通过为比特币中特定的UTXO设置一个颜色来发行新的货币。“彩币”递归设置该交易消费的其他UTXO为与交易输入相同的颜色。这样可以让用户钱包只保存特定颜色的UTXO并像普通比特币一样发送它们或回溯区块链来确定他们收到任意UTXO的颜色。
  *  **Metacoins** metacoin的想法是在比特币之上，有一个协议使用比特币交易来存储metacoin交易，但有一个不同的状态转换函数APPLY'。由于metacoin不能阻止无效的交易进入比特币区块链，所以加入了一条规则：如果APPLY'(S,TX)返回错误，协议默认执行APPLY'(S,TX) = S。这样提供了一种简单的机制去创建任意的加密协议，或许还包括比特币自身都无法实现的新特性，同时又有非常低的开发成本，因为挖矿和网络协议已经由比特币处理。Metacoin已经被用来实现某些种类的金融合约，名称注册和去中心化的交易所。

因此，总得来说，有两种方式来实现共识协议：创建一个独立的网络；在比特币之上创建一个协议。前一种方法，虽然在Namecoin这样的例子中相当成功，但很难实现；每个单独的实现都需要启动一个独立的区块链，以及创建和测试所有必要的状态转换和网络节点。另外，我们预计这些使用去中心化共识技术的应用遵循幂律分布，即大部分应用太小而不能保证它们自己的链。而且我们注意到，存在很多种的去中心应用，特别是去中心自治组织DAOs。

另一方面，基于比特币的方法，缺点是它并没有继承比特币的简化支付验证特性。SPV适用于比特币是因为它可以用区块链深度作为一种验证代理。一旦一个交易的之前的交易已经足够深，则可以很安全地认为它们已经是状态中合法的一部分。基于比特币的Meta协议在自己的上下文中，并不能阻止区块链包含那些无效的交易。因此，一个完全安全的SPV meta协议需要向前扫描一直到比特币区块链的开始来确定某些交易是否有效。当前，所有基于比特币实现的“轻量”Meta协议都依赖于一个受信任的服务器来提供数据，一个可以说是最高次最优化的结果，考虑到加密货币一个主要的目的就是消除信任设施。

## 脚本编程
即使没有任何扩展，比特币也确实促进了一个弱版本的“智能合约”概念的出现。比特币中的UTXO不仅可以被公钥，也可以被更复杂的基于stack栈的编程语言脚本所有。在这个例子中，花费UTXO的交易必须提供满足脚本的数据。实际上，即使是基本的公钥所有权机制也是通过脚本实现的：脚本输入椭圆曲线签名，对交易和拥有该UTXO的地址进行验证，如果成功返回1，否则返回0。还有其他更复杂的各种用途的脚本。例如，你可以构建一个需要2/3的私钥签名才能进行验证的脚本（称为“多重签名”）。这种方式对合作账户，安全储蓄账户以及一些商户托管账户场景很有用。脚本也可以用于支付赏金给计算难题的解决方案。你甚至可以构建一个脚本，比如声明“如果你能提供SPV证据证明你发送了一个等额的Dogecoin给我，那么这个比特币UTXO就是你的。”，本质上就是允许了去中心化的跨币交换。

但比特币中的脚本化语言有几个重要的限制：  
  * **缺乏图灵完备性** 就是说，尽管比特币支持很大一部分的计算子集，但它并不支持所有的计算。主要缺少的是循环，这主要是为了避免验证交易时出现无线循环；理论上，对于脚本程序员来说这是可以克服的，因为任何循环都可以通过if语句简单的重复底层代码多次来模拟，但这导致脚本占用了大量空间。例如，实现另一种替代的椭圆曲线签名算法可能需要256轮重复的乘法运算，每一轮计算都要单独包含在代码里。
  * **值无感知** UTXO脚本无法对可取款账户提供细粒度的控制。例如，一个强有力的oracle合约例子是套期保值合约，A和B存入等值$1000的BTC，30天后脚本发送等值$1000的BTC给A，剩余的给B，这要求oracle直到1 BTC值多少美元。即使是在当时，在信任和基础设施方面，这也是对全中心化的解决方案的一个巨大的改进。但UTXO是一个整体的，唯一的方式就是比较低效地生成很多各种面额的UTXO，让输出选择哪个发送给A，哪个发送给B。
  * **缺少状态** UTXO要么被花费，要么没有被花费。多阶段的合约或脚本没有办法保存其他中间状态。这使得生成多阶段合约、去中心化交易报价和两阶段加密提交协议（对安全计算赏金是必须的）很困难。同时也意味着UTXO只能被用于创建简单的，一次性的合约，而不是复杂的“多状态”的合约。并使得meta协议难以实现。二值状态以及对值的无感知也决定了另外一个重要的应用，即取款限制，也是不可能的。
  * **区块链无感知** UTXO对区块链数据是无感知的，比如nonce，timestamp，上一个块的hash等。这严重地限制了在赌博以及其他几种场景中的应用，这使脚本语言丧失了随机性带来的潜在的价值。

因此，我们看到了三种基于加密货币来创建高级应用的方法：创建新的区块链；在比特币之上使用脚本；在比特币之上创建mata协议。创建新的区块链可以不受限制地自由地创建新的特性，但是成本却是开发时间、自力更生（原词“bootstrapping effort”）和安全性。使用脚本易于实现和标准化，但功能有限。而meta协议，尽管比较简单，但存在伸缩性不好的缺点。通过以太坊，我们希望创建另一个框架，来提供更大的开发简单性及更强的轻量客户端属性方面的增益，同时允许应用共享成本低廉的环境和区块链安全。

## 以太坊
以太坊的目的是建立一种建立去中心化应用的替代协议，它提供不同的折中组合，我们认为这对于大部分去中心化应用都会是非常有用的，并且特别关注了，快速开发时间、小而很少使用的应用的安全性以及不同应用彼此交互能力这些非常重要的功能的应用场景。以太坊实现这个目标的方法是创建一个，本质上来说，最根本的抽象基础层：一个内置图灵完备编程语言的区块链，它允许任何人写智能合约和可以创建任意所有权规则、交易格式和状态转换函数的去中心化应用。一个简单版本的Namecoin只需要两行代码，其他货币和信用体系（原词“reputation system”）等协议可以不超过20行代码。智能合约（一种加密“盒子”，包含了值并且只有满足特定条件才能解锁），也可以创建在该平台之上。这要比比特币的脚本强大的多，因为添加了图灵完备性，值感知，区块链感知和状态。

### 思想（原词“Philosophy”）
以太坊背后的设计目的是遵守下列规则：
1. **简单性** 以太坊协议应该尽可能简单，即使需要更多的数据存储或牺牲一些时间效率。一个正常的程序员应该能遵守和实现全部的规范。这样他才能充分领会加密货币带来的前所未有的（原词“unprecedented”）民主化潜力，进一步推动以太坊的愿景，即成为一个向所有人开放的协议。任何增加复杂性的优化只有在它提供了重大的益处时才能被包含进来。
2. **通用性** 以太坊设计思想的一个基础部分是，以太坊并没有特性。相反，以太坊提供一个内部图灵完备的脚本编程语言。程序员可以使用该语言创建任何可以数学上定义的智能合约或交易类型。想要发明自己的金融衍生品？通过以太坊，你可以。想创造自己的货币?通过以太坊合约，你也可以。想要创建全量的Daemon和Skynet（注：两个美国科幻电影中的分布式网络），你可能需要几千个联锁的合约。
3. **模块化** 以太坊协议的各部分应该设计得尽可能模块化和独立。随着开发进程，我们的目标是创建这样一个应用：如果一个人在一个地方做了很小的修改，应用栈可以继续工作而不需要额外的修改。Ethash、改版的Patricia树和RLP应该，实际也是，实现为相互独立的功能完全的库。如此一来，即使以太坊不需要某些功能，这些功能也可以用在其他协议中。以太坊开发应该最大化地完成，这样可以造福整个加密货币生态系统，而不是只是自己。
4. **敏捷性** 以太坊协议的细节并不是固定不变的。尽管我们对于上层结构的修改非常谨慎，如sharding路线图，抽象执行，数据可用性仅限于共识等。开发过程中后期的计算测试使我们发现，某些修改，如协议架构和以太坊虚拟机EVM，极大地提升了伸缩性和安全性。只要有这样的机会，我们就会采纳。
5. **无差别对待和无审查** 协议不应该主动限制或组织特定种类的用法。协议中所有监管机制都应该设计为直接管控损害，而不试图抵制特定的不期望的应用。程序员甚至可以在以太坊上运行无限循环脚本任意长时间，只要他们愿意支付每个计算步骤的交易费用。

### 以太坊账号

## 参考文献：
1.	白皮书 https://github.com/ethereum/wiki/wiki/White-Paper


